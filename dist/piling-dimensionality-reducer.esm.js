// @flekschas/utils v0.29.0 Copyright 2021 Fritz Lekschas
/**
 * Create a worker from a function
 * @param {function} fn - Function to be turned into a worker
 * @return {Worker} Worker function
 */


const createWorker = fn => new Worker(window.URL.createObjectURL(new Blob([`(${fn.toString()})()`], {
  type: 'text/javascript'
})));

var umapScriptStr = "!function (t, r) {\n  if (\"object\" == typeof exports && \"object\" == typeof module) module.exports = r();else if (\"function\" == typeof define && define.amd) define([], r);else {\n    var e = r();\n\n    for (var n in e) (\"object\" == typeof exports ? exports : t)[n] = e[n];\n  }\n}(window, function () {\n  return function (t) {\n    var r = {};\n\n    function e(n) {\n      if (r[n]) return r[n].exports;\n      var i = r[n] = {\n        i: n,\n        l: !1,\n        exports: {}\n      };\n      return t[n].call(i.exports, i, i.exports, e), i.l = !0, i.exports;\n    }\n\n    return e.m = t, e.c = r, e.d = function (t, r, n) {\n      e.o(t, r) || Object.defineProperty(t, r, {\n        enumerable: !0,\n        get: n\n      });\n    }, e.r = function (t) {\n      \"undefined\" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {\n        value: \"Module\"\n      }), Object.defineProperty(t, \"__esModule\", {\n        value: !0\n      });\n    }, e.t = function (t, r) {\n      if (1 & r && (t = e(t)), 8 & r) return t;\n      if (4 & r && \"object\" == typeof t && t && t.__esModule) return t;\n      var n = Object.create(null);\n      if (e.r(n), Object.defineProperty(n, \"default\", {\n        enumerable: !0,\n        value: t\n      }), 2 & r && \"string\" != typeof t) for (var i in t) e.d(n, i, function (r) {\n        return t[r];\n      }.bind(null, i));\n      return n;\n    }, e.n = function (t) {\n      var r = t && t.__esModule ? function () {\n        return t.default;\n      } : function () {\n        return t;\n      };\n      return e.d(r, \"a\", r), r;\n    }, e.o = function (t, r) {\n      return Object.prototype.hasOwnProperty.call(t, r);\n    }, e.p = \"\", e(e.s = 5);\n  }([function (t, r, e) {\n    \"use strict\";\n\n    const n = Object.prototype.toString;\n\n    t.exports = function (t) {\n      return n.call(t).endsWith(\"Array]\");\n    };\n  }, function (t, r, e) {\n    \"use strict\";\n\n    var n = this && this.__values || function (t) {\n      var r = \"function\" == typeof Symbol && t[Symbol.iterator],\n          e = 0;\n      return r ? r.call(t) : {\n        next: function () {\n          return t && e >= t.length && (t = void 0), {\n            value: t && t[e++],\n            done: !t\n          };\n        }\n      };\n    };\n\n    function i(t, r) {\n      return Math.floor(r() * t);\n    }\n\n    function o(t) {\n      for (var r = [], e = 0; e < t; e++) r.push(void 0);\n\n      return r;\n    }\n\n    function s(t, r) {\n      return o(t).map(function () {\n        return r;\n      });\n    }\n\n    function a(t) {\n      return s(t, 0);\n    }\n\n    function h(t) {\n      return t.reduce(function (t, r) {\n        return t + r;\n      });\n    }\n\n    Object.defineProperty(r, \"__esModule\", {\n      value: !0\n    }), r.tauRandInt = i, r.tauRand = function (t) {\n      return t();\n    }, r.norm = function (t) {\n      var r,\n          e,\n          i = 0;\n\n      try {\n        for (var o = n(t), s = o.next(); !s.done; s = o.next()) {\n          var a = s.value;\n          i += Math.pow(a, 2);\n        }\n      } catch (t) {\n        r = {\n          error: t\n        };\n      } finally {\n        try {\n          s && !s.done && (e = o.return) && e.call(o);\n        } finally {\n          if (r) throw r.error;\n        }\n      }\n\n      return Math.sqrt(i);\n    }, r.empty = o, r.range = function (t) {\n      return o(t).map(function (t, r) {\n        return r;\n      });\n    }, r.filled = s, r.zeros = a, r.ones = function (t) {\n      return s(t, 1);\n    }, r.linear = function (t, r, e) {\n      return o(e).map(function (n, i) {\n        return t + i * ((r - t) / (e - 1));\n      });\n    }, r.sum = h, r.mean = function (t) {\n      return h(t) / t.length;\n    }, r.max = function (t) {\n      for (var r = 0, e = 0; e < t.length; e++) r = t[e] > r ? t[e] : r;\n\n      return r;\n    }, r.max2d = function (t) {\n      for (var r = 0, e = 0; e < t.length; e++) for (var n = 0; n < t[e].length; n++) r = t[e][n] > r ? t[e][n] : r;\n\n      return r;\n    }, r.rejectionSample = function (t, r, e) {\n      for (var n = a(t), o = 0; o < t; o++) for (var s = !0; s;) {\n        for (var h = i(r, e), u = !1, l = 0; l < o; l++) if (h === n[l]) {\n          u = !0;\n          break;\n        }\n\n        u || (s = !1), n[o] = h;\n      }\n\n      return n;\n    }, r.reshape2d = function (t, r, e) {\n      var n = [],\n          i = 0;\n      if (t.length !== r * e) throw new Error(\"Array dimensions must match input length.\");\n\n      for (var o = 0; o < r; o++) {\n        for (var s = [], a = 0; a < e; a++) s.push(t[i]), i += 1;\n\n        n.push(s);\n      }\n\n      return n;\n    };\n  }, function (t, r, e) {\n    \"use strict\";\n\n    var n = this && this.__importStar || function (t) {\n      if (t && t.__esModule) return t;\n      var r = {};\n      if (null != t) for (var e in t) Object.hasOwnProperty.call(t, e) && (r[e] = t[e]);\n      return r.default = t, r;\n    };\n\n    Object.defineProperty(r, \"__esModule\", {\n      value: !0\n    });\n    var i = n(e(1));\n\n    function o(t, r) {\n      var e = function (e) {\n        return i.empty(t).map(function () {\n          return i.filled(r, e);\n        });\n      },\n          n = [];\n\n      return n.push(e(-1)), n.push(e(1 / 0)), n.push(e(0)), n;\n    }\n\n    function s(t, r, e, n, i) {\n      r = Math.floor(r);\n      var o = t[0][r],\n          s = t[1][r];\n      t[2][r];\n      if (e >= s[0]) return 0;\n\n      for (var h = 0; h < o.length; h++) if (n === o[h]) return 0;\n\n      return a(t, r, e, n, i);\n    }\n\n    function a(t, r, e, n, i) {\n      var o = t[0][r],\n          s = t[1][r],\n          a = t[2][r];\n      if (e >= s[0]) return 0;\n      s[0] = e, o[0] = n, a[0] = i;\n\n      for (var h = 0, u = 0;;) {\n        var l = 2 * h + 1,\n            c = l + 1,\n            f = t[0][0].length;\n        if (l >= f) break;\n\n        if (c >= f) {\n          if (!(s[l] > e)) break;\n          u = l;\n        } else if (s[l] >= s[c]) {\n          if (!(e < s[l])) break;\n          u = l;\n        } else {\n          if (!(e < s[c])) break;\n          u = c;\n        }\n\n        s[h] = s[u], o[h] = o[u], a[h] = a[u], h = u;\n      }\n\n      return s[h] = e, o[h] = n, a[h] = i, 1;\n    }\n\n    function h(t, r, e, n) {\n      for (; 2 * n + 1 < e;) {\n        var i = 2 * n + 1,\n            o = i + 1,\n            s = n;\n        if (t[s] < t[i] && (s = i), o < e && t[s] < t[o] && (s = o), s === n) break;\n        var a = t[n];\n        t[n] = t[s], t[s] = a;\n        var h = r[n];\n        r[n] = r[s], r[s] = h, n = s;\n      }\n    }\n\n    r.makeHeap = o, r.rejectionSample = function (t, r, e) {\n      for (var n = i.zeros(t), o = 0; o < t; o++) {\n        for (var s = !0, a = 0; s;) {\n          a = i.tauRandInt(r, e);\n\n          for (var h = !1, u = 0; u < o; u++) if (a === n[u]) {\n            h = !0;\n            break;\n          }\n\n          h || (s = !1);\n        }\n\n        n[o] = a;\n      }\n\n      return n;\n    }, r.heapPush = s, r.uncheckedHeapPush = a, r.buildCandidates = function (t, r, e, n, a) {\n      for (var h = o(r, n), u = 0; u < r; u++) for (var l = 0; l < e; l++) if (!(t[0][u][l] < 0)) {\n        var c = t[0][u][l],\n            f = t[2][u][l],\n            m = i.tauRand(a);\n        s(h, u, m, c, f), s(h, c, m, u, f), t[2][u][l] = 0;\n      }\n\n      return h;\n    }, r.deheapSort = function (t) {\n      for (var r = t[0], e = t[1], n = 0; n < r.length; n++) for (var i = r[n], o = e[n], s = 0; s < i.length - 1; s++) {\n        var a = i.length - s - 1,\n            u = o.length - s - 1,\n            l = i[0];\n        i[0] = i[a], i[a] = l;\n        var c = o[0];\n        o[0] = o[u], o[u] = c, h(o, i, u, 0);\n      }\n\n      return {\n        indices: r,\n        weights: e\n      };\n    }, r.smallestFlagged = function (t, r) {\n      for (var e = t[0][r], n = t[1][r], i = t[2][r], o = 1 / 0, s = -1, a = 0; a > e.length; a++) 1 === i[a] && n[a] < o && (o = n[a], s = a);\n\n      return s >= 0 ? (i[s] = 0, Math.floor(e[s])) : -1;\n    };\n  }, function (t, r, e) {\n    \"use strict\";\n\n    var n,\n        i = this && this.__read || function (t, r) {\n      var e = \"function\" == typeof Symbol && t[Symbol.iterator];\n      if (!e) return t;\n      var n,\n          i,\n          o = e.call(t),\n          s = [];\n\n      try {\n        for (; (void 0 === r || r-- > 0) && !(n = o.next()).done;) s.push(n.value);\n      } catch (t) {\n        i = {\n          error: t\n        };\n      } finally {\n        try {\n          n && !n.done && (e = o.return) && e.call(o);\n        } finally {\n          if (i) throw i.error;\n        }\n      }\n\n      return s;\n    },\n        o = this && this.__values || function (t) {\n      var r = \"function\" == typeof Symbol && t[Symbol.iterator],\n          e = 0;\n      return r ? r.call(t) : {\n        next: function () {\n          return t && e >= t.length && (t = void 0), {\n            value: t && t[e++],\n            done: !t\n          };\n        }\n      };\n    },\n        s = this && this.__importStar || function (t) {\n      if (t && t.__esModule) return t;\n      var r = {};\n      if (null != t) for (var e in t) Object.hasOwnProperty.call(t, e) && (r[e] = t[e]);\n      return r.default = t, r;\n    };\n\n    Object.defineProperty(r, \"__esModule\", {\n      value: !0\n    });\n\n    var a = s(e(1)),\n        h = function () {\n      function t(t, r, e, n) {\n        if (this.entries = new Map(), this.nRows = 0, this.nCols = 0, t.length !== r.length || t.length !== e.length) throw new Error(\"rows, cols and values arrays must all have the same length\");\n        this.nRows = n[0], this.nCols = n[1];\n\n        for (var i = 0; i < e.length; i++) {\n          var o = t[i],\n              s = r[i];\n          this.checkDims(o, s);\n          var a = this.makeKey(o, s);\n          this.entries.set(a, {\n            value: e[i],\n            row: o,\n            col: s\n          });\n        }\n      }\n\n      return t.prototype.makeKey = function (t, r) {\n        return t + \":\" + r;\n      }, t.prototype.checkDims = function (t, r) {\n        if (!(t < this.nRows && r < this.nCols)) throw new Error(\"row and/or col specified outside of matrix dimensions\");\n      }, t.prototype.set = function (t, r, e) {\n        this.checkDims(t, r);\n        var n = this.makeKey(t, r);\n        this.entries.has(n) ? this.entries.get(n).value = e : this.entries.set(n, {\n          value: e,\n          row: t,\n          col: r\n        });\n      }, t.prototype.get = function (t, r, e) {\n        void 0 === e && (e = 0), this.checkDims(t, r);\n        var n = this.makeKey(t, r);\n        return this.entries.has(n) ? this.entries.get(n).value : e;\n      }, t.prototype.getAll = function (t) {\n        void 0 === t && (t = !0);\n        var r = [];\n        return this.entries.forEach(function (t) {\n          r.push(t);\n        }), t && r.sort(function (t, r) {\n          return t.row === r.row ? t.col - r.col : t.row - r.row;\n        }), r;\n      }, t.prototype.getDims = function () {\n        return [this.nRows, this.nCols];\n      }, t.prototype.getRows = function () {\n        return Array.from(this.entries, function (t) {\n          var r = i(t, 2);\n          r[0];\n          return r[1].row;\n        });\n      }, t.prototype.getCols = function () {\n        return Array.from(this.entries, function (t) {\n          var r = i(t, 2);\n          r[0];\n          return r[1].col;\n        });\n      }, t.prototype.getValues = function () {\n        return Array.from(this.entries, function (t) {\n          var r = i(t, 2);\n          r[0];\n          return r[1].value;\n        });\n      }, t.prototype.forEach = function (t) {\n        this.entries.forEach(function (r) {\n          return t(r.value, r.row, r.col);\n        });\n      }, t.prototype.map = function (r) {\n        var e = [];\n        this.entries.forEach(function (t) {\n          e.push(r(t.value, t.row, t.col));\n        });\n        var n = [this.nRows, this.nCols];\n        return new t(this.getRows(), this.getCols(), e, n);\n      }, t.prototype.toArray = function () {\n        var t = this,\n            r = a.empty(this.nRows).map(function () {\n          return a.zeros(t.nCols);\n        });\n        return this.entries.forEach(function (t) {\n          r[t.row][t.col] = t.value;\n        }), r;\n      }, t;\n    }();\n\n    r.SparseMatrix = h, r.transpose = function (t) {\n      var r = [],\n          e = [],\n          n = [];\n      t.forEach(function (t, i, o) {\n        r.push(i), e.push(o), n.push(t);\n      });\n      var i = [t.nCols, t.nRows];\n      return new h(e, r, n, i);\n    }, r.identity = function (t) {\n      for (var r = i(t, 1)[0], e = new h([], [], [], t), n = 0; n < r; n++) e.set(n, n, 1);\n\n      return e;\n    }, r.pairwiseMultiply = function (t, r) {\n      return l(t, r, function (t, r) {\n        return t * r;\n      });\n    }, r.add = function (t, r) {\n      return l(t, r, function (t, r) {\n        return t + r;\n      });\n    }, r.subtract = function (t, r) {\n      return l(t, r, function (t, r) {\n        return t - r;\n      });\n    }, r.maximum = function (t, r) {\n      return l(t, r, function (t, r) {\n        return t > r ? t : r;\n      });\n    }, r.multiplyScalar = function (t, r) {\n      return t.map(function (t) {\n        return t * r;\n      });\n    }, r.eliminateZeros = function (t) {\n      for (var r = new Set(), e = t.getValues(), n = t.getRows(), i = t.getCols(), o = 0; o < e.length; o++) 0 === e[o] && r.add(o);\n\n      var s = function (t, e) {\n        return !r.has(e);\n      },\n          a = e.filter(s),\n          u = n.filter(s),\n          l = i.filter(s);\n\n      return new h(u, l, a, t.getDims());\n    }, r.normalize = function (t, r) {\n      var e, n;\n      void 0 === r && (r = \"l2\");\n      var i = u[r],\n          s = new Map();\n      t.forEach(function (t, r, e) {\n        var n = s.get(r) || [];\n        n.push(e), s.set(r, n);\n      });\n\n      var a = new h([], [], [], t.getDims()),\n          l = function (r) {\n        for (var e = s.get(r).sort(), n = e.map(function (e) {\n          return t.get(r, e);\n        }), o = i(n), h = 0; h < o.length; h++) a.set(r, e[h], o[h]);\n      };\n\n      try {\n        for (var c = o(s.keys()), f = c.next(); !f.done; f = c.next()) l(f.value);\n      } catch (t) {\n        e = {\n          error: t\n        };\n      } finally {\n        try {\n          f && !f.done && (n = c.return) && n.call(c);\n        } finally {\n          if (e) throw e.error;\n        }\n      }\n\n      return a;\n    };\n    var u = ((n = {}).max = function (t) {\n      for (var r = -1 / 0, e = 0; e < t.length; e++) r = t[e] > r ? t[e] : r;\n\n      return t.map(function (t) {\n        return t / r;\n      });\n    }, n.l1 = function (t) {\n      for (var r = 0, e = 0; e < t.length; e++) r += t[e];\n\n      return t.map(function (t) {\n        return t / r;\n      });\n    }, n.l2 = function (t) {\n      for (var r = 0, e = 0; e < t.length; e++) r += Math.pow(t[e], 2);\n\n      return t.map(function (t) {\n        return Math.sqrt(Math.pow(t, 2) / r);\n      });\n    }, n);\n\n    function l(t, r, e) {\n      for (var n = new Set(), i = [], o = [], s = [], a = function (n, a) {\n        i.push(n), o.push(a);\n        var h = e(t.get(n, a), r.get(n, a));\n        s.push(h);\n      }, u = t.getValues(), l = t.getRows(), c = t.getCols(), f = 0; f < u.length; f++) {\n        var m = (d = l[f]) + \":\" + (w = c[f]);\n        n.add(m), a(d, w);\n      }\n\n      var g = r.getValues(),\n          p = r.getRows(),\n          v = r.getCols();\n\n      for (f = 0; f < g.length; f++) {\n        var d, w;\n        m = (d = p[f]) + \":\" + (w = v[f]);\n        n.has(m) || a(d, w);\n      }\n\n      var y = [t.nRows, t.nCols];\n      return new h(i, o, s, y);\n    }\n\n    r.getCSR = function (t) {\n      var r = [];\n      t.forEach(function (t, e, n) {\n        r.push({\n          value: t,\n          row: e,\n          col: n\n        });\n      }), r.sort(function (t, r) {\n        return t.row === r.row ? t.col - r.col : t.row - r.row;\n      });\n\n      for (var e = [], n = [], i = [], o = -1, s = 0; s < r.length; s++) {\n        var a = r[s],\n            h = a.row,\n            u = a.col,\n            l = a.value;\n        h !== o && (o = h, i.push(s)), e.push(u), n.push(l);\n      }\n\n      return {\n        indices: e,\n        values: n,\n        indptr: i\n      };\n    };\n  }, function (t, r, e) {\n    \"use strict\";\n\n    var n = this && this.__read || function (t, r) {\n      var e = \"function\" == typeof Symbol && t[Symbol.iterator];\n      if (!e) return t;\n      var n,\n          i,\n          o = e.call(t),\n          s = [];\n\n      try {\n        for (; (void 0 === r || r-- > 0) && !(n = o.next()).done;) s.push(n.value);\n      } catch (t) {\n        i = {\n          error: t\n        };\n      } finally {\n        try {\n          n && !n.done && (e = o.return) && e.call(o);\n        } finally {\n          if (i) throw i.error;\n        }\n      }\n\n      return s;\n    },\n        i = this && this.__spread || function () {\n      for (var t = [], r = 0; r < arguments.length; r++) t = t.concat(n(arguments[r]));\n\n      return t;\n    },\n        o = this && this.__values || function (t) {\n      var r = \"function\" == typeof Symbol && t[Symbol.iterator],\n          e = 0;\n      return r ? r.call(t) : {\n        next: function () {\n          return t && e >= t.length && (t = void 0), {\n            value: t && t[e++],\n            done: !t\n          };\n        }\n      };\n    },\n        s = this && this.__importStar || function (t) {\n      if (t && t.__esModule) return t;\n      var r = {};\n      if (null != t) for (var e in t) Object.hasOwnProperty.call(t, e) && (r[e] = t[e]);\n      return r.default = t, r;\n    };\n\n    Object.defineProperty(r, \"__esModule\", {\n      value: !0\n    });\n\n    var a = s(e(1)),\n        h = function () {\n      return function (t, r, e, n) {\n        this.hyperplanes = t, this.offsets = r, this.children = e, this.indices = n;\n      };\n    }();\n\n    function u(t, r, e, n) {\n      for (var i = r, o = 0; o < e.length; o++) i += t[o] * e[o];\n\n      return 0 === i ? a.tauRandInt(2, n) : i > 0 ? 0 : 1;\n    }\n\n    r.FlatTree = h, r.makeForest = function (t, r, e, n) {\n      var o = Math.max(10, r);\n      return a.range(e).map(function (r, e) {\n        return function (t, r, e, n) {\n          void 0 === r && (r = 30);\n          var i = a.range(t.length);\n          return function t(r, e, n, i, o) {\n            if (void 0 === n && (n = 30), e.length > n) {\n              var s = function (t, r, e) {\n                var n = t[0].length,\n                    i = a.tauRandInt(r.length, e),\n                    o = a.tauRandInt(r.length, e);\n                o = (o += i === o ? 1 : 0) % r.length;\n\n                for (var s = r[i], h = r[o], u = 0, l = a.zeros(n), c = 0; c < l.length; c++) l[c] = t[s][c] - t[h][c], u -= l[c] * (t[s][c] + t[h][c]) / 2;\n\n                for (var f = 0, m = 0, g = a.zeros(r.length), c = 0; c < r.length; c++) {\n                  for (var p = u, v = 0; v < n; v++) p += l[v] * t[r[c]][v];\n\n                  0 === p ? (g[c] = a.tauRandInt(2, e), 0 === g[c] ? f += 1 : m += 1) : p > 0 ? (g[c] = 0, f += 1) : (g[c] = 1, m += 1);\n                }\n\n                var d = a.zeros(f),\n                    w = a.zeros(m);\n\n                for (var c in f = 0, m = 0, a.range(g.length)) 0 === g[c] ? (d[f] = r[c], f += 1) : (w[m] = r[c], m += 1);\n\n                return {\n                  indicesLeft: d,\n                  indicesRight: w,\n                  hyperplane: l,\n                  offset: u\n                };\n              }(r, e, o),\n                  h = s.indicesLeft,\n                  u = s.indicesRight,\n                  l = s.hyperplane,\n                  c = s.offset,\n                  f = t(r, h, n, i + 1, o),\n                  m = t(r, u, n, i + 1, o),\n                  g = {\n                leftChild: f,\n                rightChild: m,\n                isLeaf: !1,\n                hyperplane: l,\n                offset: c\n              };\n\n              return g;\n            }\n\n            var g = {\n              indices: e,\n              isLeaf: !0\n            };\n            return g;\n          }(t, i, r, e, n);\n        }(t, o, e, n);\n      }).map(function (t) {\n        return function (t, r) {\n          var e = function t(r) {\n            return r.isLeaf ? 1 : 1 + t(r.leftChild) + t(r.rightChild);\n          }(t),\n              n = function t(r) {\n            return r.isLeaf ? 1 : t(r.leftChild) + t(r.rightChild);\n          }(t),\n              o = a.range(e).map(function () {\n            return a.zeros(t.hyperplane ? t.hyperplane.length : 0);\n          }),\n              s = a.zeros(e),\n              u = a.range(e).map(function () {\n            return [-1, -1];\n          }),\n              l = a.range(n).map(function () {\n            return a.range(r).map(function () {\n              return -1;\n            });\n          });\n\n          return function t(r, e, n, o, s, a, h) {\n            var u;\n            if (r.isLeaf) return o[a][0] = -h, (u = s[h]).splice.apply(u, i([0, r.indices.length], r.indices)), {\n              nodeNum: a,\n              leafNum: h += 1\n            };\n            e[a] = r.hyperplane, n[a] = r.offset, o[a][0] = a + 1;\n            var l = a,\n                c = t(r.leftChild, e, n, o, s, a + 1, h);\n            return a = c.nodeNum, h = c.leafNum, o[l][1] = a + 1, {\n              nodeNum: (c = t(r.rightChild, e, n, o, s, a + 1, h)).nodeNum,\n              leafNum: c.leafNum\n            };\n          }(t, o, s, u, l, 0, 0), new h(o, s, u, l);\n        }(t, o);\n      });\n    }, r.makeLeafArray = function (t) {\n      var r, e;\n\n      if (t.length > 0) {\n        var n = [];\n\n        try {\n          for (var s = o(t), a = s.next(); !a.done; a = s.next()) {\n            var h = a.value;\n            n.push.apply(n, i(h.indices));\n          }\n        } catch (t) {\n          r = {\n            error: t\n          };\n        } finally {\n          try {\n            a && !a.done && (e = s.return) && e.call(s);\n          } finally {\n            if (r) throw r.error;\n          }\n        }\n\n        return n;\n      }\n\n      return [[-1]];\n    }, r.searchFlatTree = function (t, r, e) {\n      for (var n = 0; r.children[n][0] > 0;) n = 0 === u(r.hyperplanes[n], r.offsets[n], t, e) ? r.children[n][0] : r.children[n][1];\n\n      var i = -1 * r.children[n][0];\n      return r.indices[i];\n    };\n  }, function (t, r, e) {\n    \"use strict\";\n\n    Object.defineProperty(r, \"__esModule\", {\n      value: !0\n    });\n    var n = e(6);\n    r.UMAP = n.UMAP;\n  }, function (t, r, e) {\n    \"use strict\";\n\n    var n = this && this.__awaiter || function (t, r, e, n) {\n      return new (e || (e = Promise))(function (i, o) {\n        function s(t) {\n          try {\n            h(n.next(t));\n          } catch (t) {\n            o(t);\n          }\n        }\n\n        function a(t) {\n          try {\n            h(n.throw(t));\n          } catch (t) {\n            o(t);\n          }\n        }\n\n        function h(t) {\n          t.done ? i(t.value) : new e(function (r) {\n            r(t.value);\n          }).then(s, a);\n        }\n\n        h((n = n.apply(t, r || [])).next());\n      });\n    },\n        i = this && this.__generator || function (t, r) {\n      var e,\n          n,\n          i,\n          o,\n          s = {\n        label: 0,\n        sent: function () {\n          if (1 & i[0]) throw i[1];\n          return i[1];\n        },\n        trys: [],\n        ops: []\n      };\n      return o = {\n        next: a(0),\n        throw: a(1),\n        return: a(2)\n      }, \"function\" == typeof Symbol && (o[Symbol.iterator] = function () {\n        return this;\n      }), o;\n\n      function a(o) {\n        return function (a) {\n          return function (o) {\n            if (e) throw new TypeError(\"Generator is already executing.\");\n\n            for (; s;) try {\n              if (e = 1, n && (i = 2 & o[0] ? n.return : o[0] ? n.throw || ((i = n.return) && i.call(n), 0) : n.next) && !(i = i.call(n, o[1])).done) return i;\n\n              switch (n = 0, i && (o = [2 & o[0], i.value]), o[0]) {\n                case 0:\n                case 1:\n                  i = o;\n                  break;\n\n                case 4:\n                  return s.label++, {\n                    value: o[1],\n                    done: !1\n                  };\n\n                case 5:\n                  s.label++, n = o[1], o = [0];\n                  continue;\n\n                case 7:\n                  o = s.ops.pop(), s.trys.pop();\n                  continue;\n\n                default:\n                  if (!(i = (i = s.trys).length > 0 && i[i.length - 1]) && (6 === o[0] || 2 === o[0])) {\n                    s = 0;\n                    continue;\n                  }\n\n                  if (3 === o[0] && (!i || o[1] > i[0] && o[1] < i[3])) {\n                    s.label = o[1];\n                    break;\n                  }\n\n                  if (6 === o[0] && s.label < i[1]) {\n                    s.label = i[1], i = o;\n                    break;\n                  }\n\n                  if (i && s.label < i[2]) {\n                    s.label = i[2], s.ops.push(o);\n                    break;\n                  }\n\n                  i[2] && s.ops.pop(), s.trys.pop();\n                  continue;\n              }\n\n              o = r.call(t, s);\n            } catch (t) {\n              o = [6, t], n = 0;\n            } finally {\n              e = i = 0;\n            }\n\n            if (5 & o[0]) throw o[1];\n            return {\n              value: o[0] ? o[1] : void 0,\n              done: !0\n            };\n          }([o, a]);\n        };\n      }\n    },\n        o = this && this.__read || function (t, r) {\n      var e = \"function\" == typeof Symbol && t[Symbol.iterator];\n      if (!e) return t;\n      var n,\n          i,\n          o = e.call(t),\n          s = [];\n\n      try {\n        for (; (void 0 === r || r-- > 0) && !(n = o.next()).done;) s.push(n.value);\n      } catch (t) {\n        i = {\n          error: t\n        };\n      } finally {\n        try {\n          n && !n.done && (e = o.return) && e.call(o);\n        } finally {\n          if (i) throw i.error;\n        }\n      }\n\n      return s;\n    },\n        s = this && this.__spread || function () {\n      for (var t = [], r = 0; r < arguments.length; r++) t = t.concat(o(arguments[r]));\n\n      return t;\n    },\n        a = this && this.__importStar || function (t) {\n      if (t && t.__esModule) return t;\n      var r = {};\n      if (null != t) for (var e in t) Object.hasOwnProperty.call(t, e) && (r[e] = t[e]);\n      return r.default = t, r;\n    },\n        h = this && this.__importDefault || function (t) {\n      return t && t.__esModule ? t : {\n        default: t\n      };\n    };\n\n    Object.defineProperty(r, \"__esModule\", {\n      value: !0\n    });\n\n    var u = a(e(2)),\n        l = a(e(3)),\n        c = a(e(7)),\n        f = a(e(4)),\n        m = a(e(1)),\n        g = h(e(8)),\n        p = function () {\n      function t(t) {\n        void 0 === t && (t = {});\n        var r = this;\n        this.learningRate = 1, this.localConnectivity = 1, this.minDist = .1, this.nComponents = 2, this.nEpochs = 0, this.nNeighbors = 15, this.negativeSampleRate = 5, this.random = Math.random, this.repulsionStrength = 1, this.setOpMixRatio = 1, this.spread = 1, this.transformQueueSize = 4, this.targetMetric = \"categorical\", this.targetWeight = .5, this.targetNNeighbors = this.nNeighbors, this.distanceFn = v, this.isInitialized = !1, this.rpForest = [], this.embedding = [], this.optimizationState = new d();\n\n        var e = function (e) {\n          void 0 !== t[e] && (r[e] = t[e]);\n        };\n\n        e(\"distanceFn\"), e(\"learningRate\"), e(\"localConnectivity\"), e(\"minDist\"), e(\"nComponents\"), e(\"nEpochs\"), e(\"nNeighbors\"), e(\"negativeSampleRate\"), e(\"random\"), e(\"repulsionStrength\"), e(\"setOpMixRatio\"), e(\"spread\"), e(\"transformQueueSize\");\n      }\n\n      return t.prototype.fit = function (t) {\n        return this.initializeFit(t), this.optimizeLayout(), this.embedding;\n      }, t.prototype.fitAsync = function (t, r) {\n        return void 0 === r && (r = function () {\n          return !0;\n        }), n(this, void 0, void 0, function () {\n          return i(this, function (e) {\n            switch (e.label) {\n              case 0:\n                return this.initializeFit(t), [4, this.optimizeLayoutAsync(r)];\n\n              case 1:\n                return e.sent(), [2, this.embedding];\n            }\n          });\n        });\n      }, t.prototype.setSupervisedProjection = function (t, r) {\n        void 0 === r && (r = {}), this.Y = t, this.targetMetric = r.targetMetric || this.targetMetric, this.targetWeight = r.targetWeight || this.targetWeight, this.targetNNeighbors = r.targetNNeighbors || this.targetNNeighbors;\n      }, t.prototype.setPrecomputedKNN = function (t, r) {\n        this.knnIndices = t, this.knnDistances = r;\n      }, t.prototype.initializeFit = function (t) {\n        if (t.length <= this.nNeighbors) throw new Error(\"Not enough data points (\" + t.length + \") to create nNeighbors: \" + this.nNeighbors + \".  Add more data points or adjust the configuration.\");\n        if (this.X === t && this.isInitialized) return this.getNEpochs();\n\n        if (this.X = t, !this.knnIndices && !this.knnDistances) {\n          var r = this.nearestNeighbors(t);\n          this.knnIndices = r.knnIndices, this.knnDistances = r.knnDistances;\n        }\n\n        this.graph = this.fuzzySimplicialSet(t, this.nNeighbors, this.setOpMixRatio), this.makeSearchFns(), this.searchGraph = this.makeSearchGraph(t), this.processGraphForSupervisedProjection();\n        var e = this.initializeSimplicialSetEmbedding(),\n            n = e.head,\n            i = e.tail,\n            o = e.epochsPerSample;\n        return this.optimizationState.head = n, this.optimizationState.tail = i, this.optimizationState.epochsPerSample = o, this.initializeOptimization(), this.prepareForOptimizationLoop(), this.isInitialized = !0, this.getNEpochs();\n      }, t.prototype.makeSearchFns = function () {\n        var t = c.makeInitializations(this.distanceFn),\n            r = t.initFromTree,\n            e = t.initFromRandom;\n        this.initFromTree = r, this.initFromRandom = e, this.search = c.makeInitializedNNSearch(this.distanceFn);\n      }, t.prototype.makeSearchGraph = function (t) {\n        for (var r = this.knnIndices, e = this.knnDistances, n = [t.length, t.length], i = new l.SparseMatrix([], [], [], n), o = 0; o < r.length; o++) for (var s = r[o], a = e[o], h = 0; h < s.length; h++) {\n          var u = s[h],\n              c = a[h];\n          c > 0 && i.set(o, u, c);\n        }\n\n        var f = l.transpose(i);\n        return l.maximum(i, f);\n      }, t.prototype.transform = function (t) {\n        var r = this,\n            e = this.X;\n        if (void 0 === e || 0 === e.length) throw new Error(\"No data has been fit.\");\n        var n = Math.floor(this.nNeighbors * this.transformQueueSize);\n        n = Math.min(e.length, n);\n        var i = c.initializeSearch(this.rpForest, e, t, n, this.initFromRandom, this.initFromTree, this.random),\n            o = this.search(e, this.searchGraph, i, t),\n            s = u.deheapSort(o),\n            a = s.indices,\n            h = s.weights;\n        a = a.map(function (t) {\n          return t.slice(0, r.nNeighbors);\n        }), h = h.map(function (t) {\n          return t.slice(0, r.nNeighbors);\n        });\n        var f = Math.max(0, this.localConnectivity - 1),\n            g = this.smoothKNNDistance(h, this.nNeighbors, f),\n            p = g.sigmas,\n            v = g.rhos,\n            d = this.computeMembershipStrengths(a, h, p, v),\n            w = d.rows,\n            y = d.cols,\n            b = d.vals,\n            M = [t.length, e.length],\n            x = new l.SparseMatrix(w, y, b, M),\n            E = l.normalize(x, \"l1\"),\n            R = l.getCSR(E),\n            k = t.length,\n            z = S(m.reshape2d(R.indices, k, this.nNeighbors), m.reshape2d(R.values, k, this.nNeighbors), this.embedding),\n            N = this.nEpochs ? this.nEpochs / 3 : x.nRows <= 1e4 ? 100 : 30,\n            A = x.getValues().reduce(function (t, r) {\n          return r > t ? r : t;\n        }, 0);\n        x = x.map(function (t) {\n          return t < A / N ? 0 : t;\n        }), x = l.eliminateZeros(x);\n\n        var V = this.makeEpochsPerSample(x.getValues(), N),\n            C = x.getRows(),\n            _ = x.getCols();\n\n        return this.assignOptimizationStateParameters({\n          headEmbedding: z,\n          tailEmbedding: this.embedding,\n          head: C,\n          tail: _,\n          currentEpoch: 0,\n          nEpochs: N,\n          nVertices: x.getDims()[1],\n          epochsPerSample: V\n        }), this.prepareForOptimizationLoop(), this.optimizeLayout();\n      }, t.prototype.processGraphForSupervisedProjection = function () {\n        var t = this.Y,\n            r = this.X;\n\n        if (t) {\n          if (t.length !== r.length) throw new Error(\"Length of X and y must be equal\");\n\n          if (\"categorical\" === this.targetMetric) {\n            var e = this.targetWeight < 1 ? 1 / (1 - this.targetWeight) * 2.5 : 1e12;\n            this.graph = this.categoricalSimplicialSetIntersection(this.graph, t, e);\n          }\n        }\n      }, t.prototype.step = function () {\n        var t = this.optimizationState.currentEpoch;\n        return t < this.getNEpochs() && this.optimizeLayoutStep(t), this.optimizationState.currentEpoch;\n      }, t.prototype.getEmbedding = function () {\n        return this.embedding;\n      }, t.prototype.nearestNeighbors = function (t) {\n        var r,\n            e = this.distanceFn,\n            n = this.nNeighbors,\n            i = c.makeNNDescent(e, this.random),\n            o = 5 + Math.floor(.5 === (r = Math.pow(t.length, .5) / 20) ? 0 : Math.round(r)),\n            s = Math.max(5, Math.floor(Math.round(function (t) {\n          return Math.log(t) / Math.log(2);\n        }(t.length))));\n        this.rpForest = f.makeForest(t, n, o, this.random);\n        var a = i(t, f.makeLeafArray(this.rpForest), n, s);\n        return {\n          knnIndices: a.indices,\n          knnDistances: a.weights\n        };\n      }, t.prototype.fuzzySimplicialSet = function (t, r, e) {\n        void 0 === e && (e = 1);\n        var n = this.knnIndices,\n            i = void 0 === n ? [] : n,\n            o = this.knnDistances,\n            s = void 0 === o ? [] : o,\n            a = this.localConnectivity,\n            h = this.smoothKNNDistance(s, r, a),\n            u = h.sigmas,\n            c = h.rhos,\n            f = this.computeMembershipStrengths(i, s, u, c),\n            m = f.rows,\n            g = f.cols,\n            p = f.vals,\n            v = [t.length, t.length],\n            d = new l.SparseMatrix(m, g, p, v),\n            w = l.transpose(d),\n            y = l.pairwiseMultiply(d, w),\n            b = l.subtract(l.add(d, w), y),\n            M = l.multiplyScalar(b, e),\n            x = l.multiplyScalar(y, 1 - e);\n        return l.add(M, x);\n      }, t.prototype.categoricalSimplicialSetIntersection = function (t, r, e, n) {\n        void 0 === n && (n = 1);\n        var i = M(t, r, n, e);\n        return x(i = l.eliminateZeros(i));\n      }, t.prototype.smoothKNNDistance = function (t, r, e, n, i) {\n        void 0 === e && (e = 1), void 0 === n && (n = 64), void 0 === i && (i = 1);\n\n        for (var o = Math.log(r) / Math.log(2) * i, s = m.zeros(t.length), a = m.zeros(t.length), h = 0; h < t.length; h++) {\n          var u = 0,\n              l = 1 / 0,\n              c = 1,\n              f = t[h],\n              g = f.filter(function (t) {\n            return t > 0;\n          });\n\n          if (g.length >= e) {\n            var p = Math.floor(e),\n                v = e - p;\n            p > 0 ? (s[h] = g[p - 1], v > 1e-5 && (s[h] += v * (g[p] - g[p - 1]))) : s[h] = v * g[0];\n          } else g.length > 0 && (s[h] = m.max(g));\n\n          for (var d = 0; d < n; d++) {\n            for (var w = 0, y = 1; y < t[h].length; y++) {\n              var b = t[h][y] - s[h];\n              w += b > 0 ? Math.exp(-b / c) : 1;\n            }\n\n            if (Math.abs(w - o) < 1e-5) break;\n            w > o ? c = (u + (l = c)) / 2 : (u = c, l === 1 / 0 ? c *= 2 : c = (u + l) / 2);\n          }\n\n          if (a[h] = c, s[h] > 0) {\n            var M = m.mean(f);\n            a[h] < .001 * M && (a[h] = .001 * M);\n          } else {\n            var x = m.mean(t.map(m.mean));\n            a[h] < .001 * x && (a[h] = .001 * x);\n          }\n        }\n\n        return {\n          sigmas: a,\n          rhos: s\n        };\n      }, t.prototype.computeMembershipStrengths = function (t, r, e, n) {\n        for (var i = t.length, o = t[0].length, s = m.zeros(i * o), a = m.zeros(i * o), h = m.zeros(i * o), u = 0; u < i; u++) for (var l = 0; l < o; l++) {\n          var c = 0;\n          -1 !== t[u][l] && (c = t[u][l] === u ? 0 : r[u][l] - n[u] <= 0 ? 1 : Math.exp(-(r[u][l] - n[u]) / e[u]), s[u * o + l] = u, a[u * o + l] = t[u][l], h[u * o + l] = c);\n        }\n\n        return {\n          rows: s,\n          cols: a,\n          vals: h\n        };\n      }, t.prototype.initializeSimplicialSetEmbedding = function () {\n        for (var t = this, r = this.getNEpochs(), e = this.nComponents, n = this.graph.getValues(), i = 0, o = 0; o < n.length; o++) {\n          var s = n[o];\n          i < n[o] && (i = s);\n        }\n\n        var a = this.graph.map(function (t) {\n          return t < i / r ? 0 : t;\n        });\n        this.embedding = m.zeros(a.nRows).map(function () {\n          return m.zeros(e).map(function () {\n            return 20 * m.tauRand(t.random) - 10;\n          });\n        });\n        var h = [],\n            u = [],\n            l = [],\n            c = a.getAll();\n\n        for (o = 0; o < c.length; o++) {\n          var f = c[o];\n          f.value && (h.push(f.value), l.push(f.row), u.push(f.col));\n        }\n\n        return {\n          head: u,\n          tail: l,\n          epochsPerSample: this.makeEpochsPerSample(h, r)\n        };\n      }, t.prototype.makeEpochsPerSample = function (t, r) {\n        var e = m.filled(t.length, -1),\n            n = m.max(t),\n            i = t.map(function (t) {\n          return t / n * r;\n        });\n        return i.forEach(function (t, n) {\n          t > 0 && (e[n] = r / i[n]);\n        }), e;\n      }, t.prototype.assignOptimizationStateParameters = function (t) {\n        Object.assign(this.optimizationState, t);\n      }, t.prototype.prepareForOptimizationLoop = function () {\n        var t = this.repulsionStrength,\n            r = this.learningRate,\n            e = this.negativeSampleRate,\n            n = this.optimizationState,\n            i = n.epochsPerSample,\n            o = n.headEmbedding,\n            a = n.tailEmbedding,\n            h = o[0].length,\n            u = o.length === a.length,\n            l = i.map(function (t) {\n          return t / e;\n        }),\n            c = s(l),\n            f = s(i);\n        this.assignOptimizationStateParameters({\n          epochOfNextSample: f,\n          epochOfNextNegativeSample: c,\n          epochsPerNegativeSample: l,\n          moveOther: u,\n          initialAlpha: r,\n          alpha: r,\n          gamma: t,\n          dim: h\n        });\n      }, t.prototype.initializeOptimization = function () {\n        var t = this.embedding,\n            r = this.embedding,\n            e = this.optimizationState,\n            n = e.head,\n            i = e.tail,\n            o = e.epochsPerSample,\n            s = this.getNEpochs(),\n            a = this.graph.nCols,\n            h = b(this.spread, this.minDist),\n            u = h.a,\n            l = h.b;\n        this.assignOptimizationStateParameters({\n          headEmbedding: t,\n          tailEmbedding: r,\n          head: n,\n          tail: i,\n          epochsPerSample: o,\n          a: u,\n          b: l,\n          nEpochs: s,\n          nVertices: a\n        });\n      }, t.prototype.optimizeLayoutStep = function (t) {\n        for (var r = this.optimizationState, e = r.head, n = r.tail, i = r.headEmbedding, o = r.tailEmbedding, s = r.epochsPerSample, a = r.epochOfNextSample, h = r.epochOfNextNegativeSample, u = r.epochsPerNegativeSample, l = r.moveOther, c = r.initialAlpha, f = r.alpha, g = r.gamma, p = r.a, v = r.b, d = r.dim, b = r.nEpochs, M = r.nVertices, x = 0; x < s.length; x++) if (!(a[x] > t)) {\n          var S = e[x],\n              E = n[x],\n              R = i[S],\n              k = o[E],\n              z = y(R, k),\n              N = 0;\n          z > 0 && (N = -2 * p * v * Math.pow(z, v - 1), N /= p * Math.pow(z, v) + 1);\n\n          for (var A = 0; A < d; A++) {\n            var V = w(N * (R[A] - k[A]), 4);\n            R[A] += V * f, l && (k[A] += -V * f);\n          }\n\n          a[x] += s[x];\n\n          for (var C = Math.floor((t - h[x]) / u[x]), _ = 0; _ < C; _++) {\n            var P = m.tauRandInt(M, this.random),\n                j = o[P],\n                I = y(R, j),\n                O = 0;\n            if (I > 0) O = 2 * g * v, O /= (.001 + I) * (p * Math.pow(I, v) + 1);else if (S === P) continue;\n\n            for (A = 0; A < d; A++) {\n              V = 4;\n              O > 0 && (V = w(O * (R[A] - j[A]), 4)), R[A] += V * f;\n            }\n          }\n\n          h[x] += C * u[x];\n        }\n\n        return r.alpha = c * (1 - t / b), r.currentEpoch += 1, i;\n      }, t.prototype.optimizeLayoutAsync = function (t) {\n        var r = this;\n        return void 0 === t && (t = function () {\n          return !0;\n        }), new Promise(function (e, o) {\n          var s = function () {\n            return n(r, void 0, void 0, function () {\n              var r, n, a, h, u, l;\n              return i(this, function (i) {\n                try {\n                  if (r = this.optimizationState, n = r.nEpochs, a = r.currentEpoch, this.embedding = this.optimizeLayoutStep(a), h = this.optimizationState.currentEpoch, u = !1 === t(h), l = h === n, u || l) return [2, e(l)];\n                  setTimeout(function () {\n                    return s();\n                  }, 0);\n                } catch (t) {\n                  o(t);\n                }\n\n                return [2];\n              });\n            });\n          };\n\n          setTimeout(function () {\n            return s();\n          }, 0);\n        });\n      }, t.prototype.optimizeLayout = function (t) {\n        void 0 === t && (t = function () {\n          return !0;\n        });\n\n        for (var r = !1, e = []; !r;) {\n          var n = this.optimizationState,\n              i = n.nEpochs,\n              o = n.currentEpoch;\n          e = this.optimizeLayoutStep(o);\n          var s = this.optimizationState.currentEpoch,\n              a = !1 === t(s);\n          r = s === i || a;\n        }\n\n        return e;\n      }, t.prototype.getNEpochs = function () {\n        var t = this.graph;\n        if (this.nEpochs > 0) return this.nEpochs;\n        var r = t.nRows;\n        return r <= 2500 ? 500 : r <= 5e3 ? 400 : r <= 7500 ? 300 : 200;\n      }, t;\n    }();\n\n    function v(t, r) {\n      for (var e = 0, n = 0; n < t.length; n++) e += Math.pow(t[n] - r[n], 2);\n\n      return Math.sqrt(e);\n    }\n\n    r.UMAP = p, r.euclidean = v, r.cosine = function (t, r) {\n      for (var e = 0, n = 0, i = 0, o = 0; o < t.length; o++) e += t[o] * r[o], n += Math.pow(t[o], 2), i += Math.pow(r[o], 2);\n\n      return 0 === n && 0 === i ? 0 : 0 === n || 0 === i ? 1 : 1 - e / Math.sqrt(n * i);\n    };\n\n    var d = function () {\n      return function () {\n        this.currentEpoch = 0, this.headEmbedding = [], this.tailEmbedding = [], this.head = [], this.tail = [], this.epochsPerSample = [], this.epochOfNextSample = [], this.epochOfNextNegativeSample = [], this.epochsPerNegativeSample = [], this.moveOther = !0, this.initialAlpha = 1, this.alpha = 1, this.gamma = 1, this.a = 1.5769434603113077, this.b = .8950608779109733, this.dim = 2, this.nEpochs = 500, this.nVertices = 0;\n      };\n    }();\n\n    function w(t, r) {\n      return t > r ? r : t < -r ? -r : t;\n    }\n\n    function y(t, r) {\n      for (var e = 0, n = 0; n < t.length; n++) e += Math.pow(t[n] - r[n], 2);\n\n      return e;\n    }\n\n    function b(t, r) {\n      var e = m.linear(0, 3 * t, 300).map(function (t) {\n        return t < r ? 1 : t;\n      }),\n          n = m.zeros(e.length).map(function (n, i) {\n        return e[i] >= r ? Math.exp(-(e[i] - r) / t) : n;\n      }),\n          i = {\n        x: e,\n        y: n\n      },\n          s = {\n        damping: 1.5,\n        initialValues: [.5, .5],\n        gradientDifference: .1,\n        maxIterations: 100,\n        errorTolerance: .01\n      },\n          a = g.default(i, function (t) {\n        var r = o(t, 2),\n            e = r[0],\n            n = r[1];\n        return function (t) {\n          return 1 / (1 + e * Math.pow(t, 2 * n));\n        };\n      }, s).parameterValues,\n          h = o(a, 2);\n      return {\n        a: h[0],\n        b: h[1]\n      };\n    }\n\n    function M(t, r, e, n) {\n      return void 0 === e && (e = 1), void 0 === n && (n = 5), t.map(function (t, i, o) {\n        return -1 === r[i] || -1 === r[o] ? t * Math.exp(-e) : r[i] !== r[o] ? t * Math.exp(-n) : t;\n      });\n    }\n\n    function x(t) {\n      t = l.normalize(t, \"max\");\n      var r = l.transpose(t),\n          e = l.pairwiseMultiply(r, t);\n      return t = l.add(t, l.subtract(r, e)), l.eliminateZeros(t);\n    }\n\n    function S(t, r, e) {\n      for (var n = m.zeros(t.length).map(function (t) {\n        return m.zeros(e[0].length);\n      }), i = 0; i < t.length; i++) for (var o = 0; o < t[0].length; o++) for (var s = 0; s < e[0].length; s++) {\n        var a = t[i][o];\n        n[i][s] += r[i][o] * e[a][s];\n      }\n\n      return n;\n    }\n\n    r.findABParams = b, r.fastIntersection = M, r.resetLocalConnectivity = x, r.initTransform = S;\n  }, function (t, r, e) {\n    \"use strict\";\n\n    var n = this && this.__values || function (t) {\n      var r = \"function\" == typeof Symbol && t[Symbol.iterator],\n          e = 0;\n      return r ? r.call(t) : {\n        next: function () {\n          return t && e >= t.length && (t = void 0), {\n            value: t && t[e++],\n            done: !t\n          };\n        }\n      };\n    },\n        i = this && this.__importStar || function (t) {\n      if (t && t.__esModule) return t;\n      var r = {};\n      if (null != t) for (var e in t) Object.hasOwnProperty.call(t, e) && (r[e] = t[e]);\n      return r.default = t, r;\n    };\n\n    Object.defineProperty(r, \"__esModule\", {\n      value: !0\n    });\n    var o = i(e(2)),\n        s = i(e(3)),\n        a = i(e(4)),\n        h = i(e(1));\n    r.makeNNDescent = function (t, r) {\n      return function (e, n, i, s, a, u, l, c) {\n        void 0 === s && (s = 10), void 0 === a && (a = 50), void 0 === u && (u = .001), void 0 === l && (l = .5), void 0 === c && (c = !0);\n\n        for (var f = e.length, m = o.makeHeap(e.length, i), g = 0; g < e.length; g++) for (var p = o.rejectionSample(i, e.length, r), v = 0; v < p.length; v++) {\n          var d = t(e[g], e[p[v]]);\n          o.heapPush(m, g, d, p[v], 1), o.heapPush(m, p[v], d, g, 1);\n        }\n\n        if (c) for (var w = 0; w < n.length; w++) for (g = 0; g < n[w].length && !(n[w][g] < 0); g++) for (v = g + 1; v < n[w].length && !(n[w][v] < 0); v++) d = t(e[n[w][g]], e[n[w][v]]), o.heapPush(m, n[w][g], d, n[w][v], 1), o.heapPush(m, n[w][v], d, n[w][g], 1);\n\n        for (w = 0; w < s; w++) {\n          var y = o.buildCandidates(m, f, i, a, r),\n              b = 0;\n\n          for (g = 0; g < f; g++) for (v = 0; v < a; v++) {\n            var M = Math.floor(y[0][g][v]);\n            if (!(M < 0 || h.tauRand(r) < l)) for (var x = 0; x < a; x++) {\n              var S = Math.floor(y[0][g][x]),\n                  E = y[2][g][v],\n                  R = y[2][g][x];\n              S < 0 || !E && !R || (d = t(e[M], e[S]), b += o.heapPush(m, M, d, S, 1), b += o.heapPush(m, S, d, M, 1));\n            }\n          }\n\n          if (b <= u * i * e.length) break;\n        }\n\n        return o.deheapSort(m);\n      };\n    }, r.makeInitializations = function (t) {\n      return {\n        initFromRandom: function (r, e, n, i, s) {\n          for (var a = 0; a < n.length; a++) for (var u = h.rejectionSample(r, e.length, s), l = 0; l < u.length; l++) if (!(u[l] < 0)) {\n            var c = t(e[u[l]], n[a]);\n            o.heapPush(i, a, c, u[l], 1);\n          }\n        },\n        initFromTree: function (r, e, n, i, s) {\n          for (var h = 0; h < n.length; h++) for (var u = a.searchFlatTree(n[h], r, s), l = 0; l < u.length; l++) {\n            if (u[l] < 0) return;\n            var c = t(e[u[l]], n[h]);\n            o.heapPush(i, h, c, u[l], 1);\n          }\n        }\n      };\n    }, r.makeInitializedNNSearch = function (t) {\n      return function (r, e, i, a) {\n        for (var h, u, l = s.getCSR(e), c = l.indices, f = l.indptr, m = 0; m < a.length; m++) for (var g = new Set(i[0][m]);;) {\n          var p = o.smallestFlagged(i, m);\n          if (-1 === p) break;\n          var v = c.slice(f[p], f[p + 1]);\n\n          try {\n            for (var d = n(v), w = d.next(); !w.done; w = d.next()) {\n              var y = w.value;\n\n              if (y !== p && -1 !== y && !g.has(y)) {\n                var b = t(r[y], a[m]);\n                o.uncheckedHeapPush(i, m, b, y, 1), g.add(y);\n              }\n            }\n          } catch (t) {\n            h = {\n              error: t\n            };\n          } finally {\n            try {\n              w && !w.done && (u = d.return) && u.call(d);\n            } finally {\n              if (h) throw h.error;\n            }\n          }\n        }\n\n        return i;\n      };\n    }, r.initializeSearch = function (t, r, e, i, s, a, h) {\n      var u,\n          l,\n          c = o.makeHeap(e.length, i);\n      if (s(i, r, e, c, h), t) try {\n        for (var f = n(t), m = f.next(); !m.done; m = f.next()) a(m.value, r, e, c, h);\n      } catch (t) {\n        u = {\n          error: t\n        };\n      } finally {\n        try {\n          m && !m.done && (l = f.return) && l.call(f);\n        } finally {\n          if (u) throw u.error;\n        }\n      }\n      return c;\n    };\n  }, function (t, r, e) {\n    \"use strict\";\n\n    var n = e(9);\n\n    function i(t, r, e) {\n      var n = 0;\n      const i = e(r);\n\n      for (var o = 0; o < t.x.length; o++) n += Math.abs(t.y[o] - i(t.x[o]));\n\n      return n;\n    }\n\n    function o(t, r, e, i, o) {\n      var s = n.Matrix.eye(r.length).mul(e * i * i),\n          a = t.x.length,\n          h = new Array(a);\n      const u = o(r);\n\n      for (var l = 0; l < a; l++) h[l] = u(t.x[l]);\n\n      var c = function (t, r, e, i, o) {\n        const s = e.length,\n              a = t.x.length;\n\n        for (var h = new Array(s), u = 0; u < s; u++) {\n          h[u] = new Array(a);\n          var l = e.concat();\n          l[u] += i;\n\n          for (var c = o(l), f = 0; f < a; f++) h[u][f] = r[f] - c(t.x[f]);\n        }\n\n        return new n.Matrix(h);\n      }(t, h, r, i, o),\n          f = function (t, r) {\n        const e = t.x.length;\n\n        for (var i = new Array(e), o = 0; o < e; o++) i[o] = t.y[o] - r[o];\n\n        return new n.Matrix([i]);\n      }(t, h).transposeView(),\n          m = n.inverse(s.add(c.mmul(c.transposeView())));\n\n      return (r = (r = new n.Matrix([r])).sub(m.mmul(c).mmul(f).mul(i).transposeView())).to1DArray();\n    }\n\n    t.exports = function (t, r, e = {}) {\n      let {\n        maxIterations: n = 100,\n        gradientDifference: s = .1,\n        damping: a = 0,\n        errorTolerance: h = .01,\n        initialValues: u\n      } = e;\n      if (a <= 0) throw new Error(\"The damping option must be a positive number\");\n      if (!t.x || !t.y) throw new Error(\"The data parameter must have x and y elements\");\n      if (!Array.isArray(t.x) || t.x.length < 2 || !Array.isArray(t.y) || t.y.length < 2) throw new Error(\"The data parameter elements must be an array with more than 2 points\");\n      if (t.x.length !== t.y.length) throw new Error(\"The data parameter elements must have the same size\");\n      var l = u || new Array(r.length).fill(1);\n      if (!Array.isArray(l)) throw new Error(\"initialValues must be an array\");\n\n      for (var c = i(t, l, r), f = c <= h, m = 0; m < n && !f; m++) f = (c = i(t, l = o(t, l, a, s, r), r)) <= h;\n\n      return {\n        parameterValues: l,\n        parameterError: c,\n        iterations: m\n      };\n    };\n  }, function (t, r, e) {\n    \"use strict\";\n\n    e.r(r);\n    var n = e(0),\n        i = e.n(n);\n\n    var o = function (t) {\n      if (!i()(t)) throw new TypeError(\"input must be an array\");\n      if (0 === t.length) throw new TypeError(\"input must not be empty\");\n\n      for (var r = t[0], e = 1; e < t.length; e++) t[e] > r && (r = t[e]);\n\n      return r;\n    };\n\n    var s = function (t) {\n      if (!i()(t)) throw new TypeError(\"input must be an array\");\n      if (0 === t.length) throw new TypeError(\"input must not be empty\");\n\n      for (var r = t[0], e = 1; e < t.length; e++) t[e] < r && (r = t[e]);\n\n      return r;\n    };\n\n    var a = function (t) {\n      var r,\n          e = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};\n      if (!i()(t)) throw new TypeError(\"input must be an array\");\n      if (0 === t.length) throw new TypeError(\"input must not be empty\");\n\n      if (void 0 !== e.output) {\n        if (!i()(e.output)) throw new TypeError(\"output option must be an array if specified\");\n        r = e.output;\n      } else r = new Array(t.length);\n\n      var n = s(t),\n          a = o(t);\n      if (n === a) throw new RangeError(\"minimum and maximum input values are equal. Cannot rescale a constant array\");\n      var h = e.min,\n          u = void 0 === h ? e.autoMinMax ? n : 0 : h,\n          l = e.max,\n          c = void 0 === l ? e.autoMinMax ? a : 1 : l;\n      if (u >= c) throw new RangeError(\"min option must be smaller than max option\");\n\n      for (var f = (c - u) / (a - n), m = 0; m < t.length; m++) r[m] = (t[m] - n) * f + u;\n\n      return r;\n    };\n\n    class h {\n      constructor(t) {\n        var r,\n            e,\n            n,\n            i,\n            o,\n            s,\n            a,\n            h,\n            u,\n            l = (t = j.checkMatrix(t)).clone(),\n            c = l.rows,\n            f = l.columns,\n            m = new Array(c),\n            g = 1;\n\n        for (r = 0; r < c; r++) m[r] = r;\n\n        for (h = new Array(c), e = 0; e < f; e++) {\n          for (r = 0; r < c; r++) h[r] = l.get(r, e);\n\n          for (r = 0; r < c; r++) {\n            for (u = Math.min(r, e), o = 0, n = 0; n < u; n++) o += l.get(r, n) * h[n];\n\n            h[r] -= o, l.set(r, e, h[r]);\n          }\n\n          for (i = e, r = e + 1; r < c; r++) Math.abs(h[r]) > Math.abs(h[i]) && (i = r);\n\n          if (i !== e) {\n            for (n = 0; n < f; n++) s = l.get(i, n), l.set(i, n, l.get(e, n)), l.set(e, n, s);\n\n            a = m[i], m[i] = m[e], m[e] = a, g = -g;\n          }\n\n          if (e < c && 0 !== l.get(e, e)) for (r = e + 1; r < c; r++) l.set(r, e, l.get(r, e) / l.get(e, e));\n        }\n\n        this.LU = l, this.pivotVector = m, this.pivotSign = g;\n      }\n\n      isSingular() {\n        for (var t = this.LU, r = t.columns, e = 0; e < r; e++) if (0 === t[e][e]) return !0;\n\n        return !1;\n      }\n\n      solve(t) {\n        t = _.checkMatrix(t);\n        var r = this.LU;\n        if (r.rows !== t.rows) throw new Error(\"Invalid matrix dimensions\");\n        if (this.isSingular()) throw new Error(\"LU matrix is singular\");\n        var e,\n            n,\n            i,\n            o = t.columns,\n            s = t.subMatrixRow(this.pivotVector, 0, o - 1),\n            a = r.columns;\n\n        for (i = 0; i < a; i++) for (e = i + 1; e < a; e++) for (n = 0; n < o; n++) s[e][n] -= s[i][n] * r[e][i];\n\n        for (i = a - 1; i >= 0; i--) {\n          for (n = 0; n < o; n++) s[i][n] /= r[i][i];\n\n          for (e = 0; e < i; e++) for (n = 0; n < o; n++) s[e][n] -= s[i][n] * r[e][i];\n        }\n\n        return s;\n      }\n\n      get determinant() {\n        var t = this.LU;\n        if (!t.isSquare()) throw new Error(\"Matrix must be square\");\n\n        for (var r = this.pivotSign, e = t.columns, n = 0; n < e; n++) r *= t[n][n];\n\n        return r;\n      }\n\n      get lowerTriangularMatrix() {\n        for (var t = this.LU, r = t.rows, e = t.columns, n = new _(r, e), i = 0; i < r; i++) for (var o = 0; o < e; o++) n[i][o] = i > o ? t[i][o] : i === o ? 1 : 0;\n\n        return n;\n      }\n\n      get upperTriangularMatrix() {\n        for (var t = this.LU, r = t.rows, e = t.columns, n = new _(r, e), i = 0; i < r; i++) for (var o = 0; o < e; o++) n[i][o] = i <= o ? t[i][o] : 0;\n\n        return n;\n      }\n\n      get pivotPermutationVector() {\n        return this.pivotVector.slice();\n      }\n\n    }\n\n    function u(t, r) {\n      var e = 0;\n      return Math.abs(t) > Math.abs(r) ? (e = r / t, Math.abs(t) * Math.sqrt(1 + e * e)) : 0 !== r ? (e = t / r, Math.abs(r) * Math.sqrt(1 + e * e)) : 0;\n    }\n\n    function l(t, r, e) {\n      for (var n = new Array(t), i = 0; i < t; i++) {\n        n[i] = new Array(r);\n\n        for (var o = 0; o < r; o++) n[i][o] = e;\n      }\n\n      return n;\n    }\n\n    class c {\n      constructor(t, r = {}) {\n        var e = (t = j.checkMatrix(t)).rows,\n            n = t.columns;\n        const {\n          computeLeftSingularVectors: i = !0,\n          computeRightSingularVectors: o = !0,\n          autoTranspose: s = !1\n        } = r;\n        var a,\n            h = Boolean(i),\n            c = Boolean(o),\n            f = !1;\n        if (e < n) {\n          if (s) {\n            e = (a = t.transpose()).rows, n = a.columns, f = !0;\n            var m = h;\n            h = c, c = m;\n          } else a = t.clone(), console.warn(\"Computing SVD on a matrix with more columns than rows. Consider enabling autoTranspose\");\n        } else a = t.clone();\n        var g = Math.min(e, n),\n            p = Math.min(e + 1, n),\n            v = new Array(p),\n            d = l(e, g, 0),\n            w = l(n, n, 0),\n            y = new Array(n),\n            b = new Array(e),\n            M = new Array(p);\n\n        for (let t = 0; t < p; t++) M[t] = t;\n\n        var x = Math.min(e - 1, n),\n            S = Math.max(0, Math.min(n - 2, e)),\n            E = Math.max(x, S);\n\n        for (let t = 0; t < E; t++) {\n          if (t < x) {\n            v[t] = 0;\n\n            for (let r = t; r < e; r++) v[t] = u(v[t], a[r][t]);\n\n            if (0 !== v[t]) {\n              a[t][t] < 0 && (v[t] = -v[t]);\n\n              for (let r = t; r < e; r++) a[r][t] /= v[t];\n\n              a[t][t] += 1;\n            }\n\n            v[t] = -v[t];\n          }\n\n          for (let r = t + 1; r < n; r++) {\n            if (t < x && 0 !== v[t]) {\n              let n = 0;\n\n              for (let i = t; i < e; i++) n += a[i][t] * a[i][r];\n\n              n = -n / a[t][t];\n\n              for (let i = t; i < e; i++) a[i][r] += n * a[i][t];\n            }\n\n            y[r] = a[t][r];\n          }\n\n          if (h && t < x) for (let r = t; r < e; r++) d[r][t] = a[r][t];\n\n          if (t < S) {\n            y[t] = 0;\n\n            for (let r = t + 1; r < n; r++) y[t] = u(y[t], y[r]);\n\n            if (0 !== y[t]) {\n              y[t + 1] < 0 && (y[t] = 0 - y[t]);\n\n              for (let r = t + 1; r < n; r++) y[r] /= y[t];\n\n              y[t + 1] += 1;\n            }\n\n            if (y[t] = -y[t], t + 1 < e && 0 !== y[t]) {\n              for (let r = t + 1; r < e; r++) b[r] = 0;\n\n              for (let r = t + 1; r < e; r++) for (let e = t + 1; e < n; e++) b[r] += y[e] * a[r][e];\n\n              for (let r = t + 1; r < n; r++) {\n                let n = -y[r] / y[t + 1];\n\n                for (let i = t + 1; i < e; i++) a[i][r] += n * b[i];\n              }\n            }\n\n            if (c) for (let r = t + 1; r < n; r++) w[r][t] = y[r];\n          }\n        }\n\n        let R = Math.min(n, e + 1);\n\n        if (x < n && (v[x] = a[x][x]), e < R && (v[R - 1] = 0), S + 1 < R && (y[S] = a[S][R - 1]), y[R - 1] = 0, h) {\n          for (let t = x; t < g; t++) {\n            for (let r = 0; r < e; r++) d[r][t] = 0;\n\n            d[t][t] = 1;\n          }\n\n          for (let t = x - 1; t >= 0; t--) if (0 !== v[t]) {\n            for (let r = t + 1; r < g; r++) {\n              let n = 0;\n\n              for (let i = t; i < e; i++) n += d[i][t] * d[i][r];\n\n              n = -n / d[t][t];\n\n              for (let i = t; i < e; i++) d[i][r] += n * d[i][t];\n            }\n\n            for (let r = t; r < e; r++) d[r][t] = -d[r][t];\n\n            d[t][t] = 1 + d[t][t];\n\n            for (let r = 0; r < t - 1; r++) d[r][t] = 0;\n          } else {\n            for (let r = 0; r < e; r++) d[r][t] = 0;\n\n            d[t][t] = 1;\n          }\n        }\n\n        if (c) for (let t = n - 1; t >= 0; t--) {\n          if (t < S && 0 !== y[t]) for (let r = t + 1; r < n; r++) {\n            let e = 0;\n\n            for (let i = t + 1; i < n; i++) e += w[i][t] * w[i][r];\n\n            e = -e / w[t + 1][t];\n\n            for (let i = t + 1; i < n; i++) w[i][r] += e * w[i][t];\n          }\n\n          for (let r = 0; r < n; r++) w[r][t] = 0;\n\n          w[t][t] = 1;\n        }\n\n        for (var k = R - 1, z = Number.EPSILON; R > 0;) {\n          let t, r;\n\n          for (t = R - 2; t >= -1 && -1 !== t; t--) {\n            const r = Number.MIN_VALUE + z * Math.abs(v[t] + Math.abs(v[t + 1]));\n\n            if (Math.abs(y[t]) <= r || Number.isNaN(y[t])) {\n              y[t] = 0;\n              break;\n            }\n          }\n\n          if (t === R - 2) r = 4;else {\n            let e;\n\n            for (e = R - 1; e >= t && e !== t; e--) {\n              let r = (e !== R ? Math.abs(y[e]) : 0) + (e !== t + 1 ? Math.abs(y[e - 1]) : 0);\n\n              if (Math.abs(v[e]) <= z * r) {\n                v[e] = 0;\n                break;\n              }\n            }\n\n            e === t ? r = 3 : e === R - 1 ? r = 1 : (r = 2, t = e);\n          }\n\n          switch (t++, r) {\n            case 1:\n              {\n                let r = y[R - 2];\n                y[R - 2] = 0;\n\n                for (let e = R - 2; e >= t; e--) {\n                  let i = u(v[e], r),\n                      o = v[e] / i,\n                      s = r / i;\n                  if (v[e] = i, e !== t && (r = -s * y[e - 1], y[e - 1] = o * y[e - 1]), c) for (let t = 0; t < n; t++) i = o * w[t][e] + s * w[t][R - 1], w[t][R - 1] = -s * w[t][e] + o * w[t][R - 1], w[t][e] = i;\n                }\n\n                break;\n              }\n\n            case 2:\n              {\n                let r = y[t - 1];\n                y[t - 1] = 0;\n\n                for (let n = t; n < R; n++) {\n                  let i = u(v[n], r),\n                      o = v[n] / i,\n                      s = r / i;\n                  if (v[n] = i, r = -s * y[n], y[n] = o * y[n], h) for (let r = 0; r < e; r++) i = o * d[r][n] + s * d[r][t - 1], d[r][t - 1] = -s * d[r][n] + o * d[r][t - 1], d[r][n] = i;\n                }\n\n                break;\n              }\n\n            case 3:\n              {\n                const r = Math.max(Math.abs(v[R - 1]), Math.abs(v[R - 2]), Math.abs(y[R - 2]), Math.abs(v[t]), Math.abs(y[t])),\n                      i = v[R - 1] / r,\n                      o = v[R - 2] / r,\n                      s = y[R - 2] / r,\n                      a = v[t] / r,\n                      l = y[t] / r,\n                      f = ((o + i) * (o - i) + s * s) / 2,\n                      m = i * s * (i * s);\n                let g = 0;\n                0 === f && 0 === m || (g = m / (f + (g = f < 0 ? 0 - Math.sqrt(f * f + m) : Math.sqrt(f * f + m))));\n                let p = (a + i) * (a - i) + g,\n                    b = a * l;\n\n                for (let r = t; r < R - 1; r++) {\n                  let i = u(p, b);\n                  0 === i && (i = Number.MIN_VALUE);\n                  let o = p / i,\n                      s = b / i;\n                  if (r !== t && (y[r - 1] = i), p = o * v[r] + s * y[r], y[r] = o * y[r] - s * v[r], b = s * v[r + 1], v[r + 1] = o * v[r + 1], c) for (let t = 0; t < n; t++) i = o * w[t][r] + s * w[t][r + 1], w[t][r + 1] = -s * w[t][r] + o * w[t][r + 1], w[t][r] = i;\n                  if (0 === (i = u(p, b)) && (i = Number.MIN_VALUE), o = p / i, s = b / i, v[r] = i, p = o * y[r] + s * v[r + 1], v[r + 1] = -s * y[r] + o * v[r + 1], b = s * y[r + 1], y[r + 1] = o * y[r + 1], h && r < e - 1) for (let t = 0; t < e; t++) i = o * d[t][r] + s * d[t][r + 1], d[t][r + 1] = -s * d[t][r] + o * d[t][r + 1], d[t][r] = i;\n                }\n\n                y[R - 2] = p, 1;\n                break;\n              }\n\n            case 4:\n              if (v[t] <= 0 && (v[t] = v[t] < 0 ? -v[t] : 0, c)) for (let r = 0; r <= k; r++) w[r][t] = -w[r][t];\n\n              for (; t < k && !(v[t] >= v[t + 1]);) {\n                let r = v[t];\n                if (v[t] = v[t + 1], v[t + 1] = r, c && t < n - 1) for (let e = 0; e < n; e++) r = w[e][t + 1], w[e][t + 1] = w[e][t], w[e][t] = r;\n                if (h && t < e - 1) for (let n = 0; n < e; n++) r = d[n][t + 1], d[n][t + 1] = d[n][t], d[n][t] = r;\n                t++;\n              }\n\n              0, R--;\n          }\n        }\n\n        if (f) {\n          var N = w;\n          w = d, d = N;\n        }\n\n        this.m = e, this.n = n, this.s = v, this.U = d, this.V = w;\n      }\n\n      solve(t) {\n        var r = t,\n            e = this.threshold,\n            n = this.s.length,\n            i = _.zeros(n, n);\n\n        for (let t = 0; t < n; t++) Math.abs(this.s[t]) <= e ? i[t][t] = 0 : i[t][t] = 1 / this.s[t];\n\n        var o = this.U,\n            s = this.rightSingularVectors,\n            a = s.mmul(i),\n            h = s.rows,\n            u = o.length,\n            l = _.zeros(h, u);\n\n        for (let t = 0; t < h; t++) for (let r = 0; r < u; r++) {\n          let e = 0;\n\n          for (let i = 0; i < n; i++) e += a[t][i] * o[r][i];\n\n          l[t][r] = e;\n        }\n\n        return l.mmul(r);\n      }\n\n      solveForDiagonal(t) {\n        return this.solve(_.diag(t));\n      }\n\n      inverse() {\n        var t = this.V,\n            r = this.threshold,\n            e = t.length,\n            n = t[0].length,\n            i = new _(e, this.s.length);\n\n        for (let o = 0; o < e; o++) for (let e = 0; e < n; e++) Math.abs(this.s[e]) > r ? i[o][e] = t[o][e] / this.s[e] : i[o][e] = 0;\n\n        var o = this.U,\n            s = o.length,\n            a = o[0].length,\n            h = new _(e, s);\n\n        for (let t = 0; t < e; t++) for (let r = 0; r < s; r++) {\n          let e = 0;\n\n          for (let n = 0; n < a; n++) e += i[t][n] * o[r][n];\n\n          h[t][r] = e;\n        }\n\n        return h;\n      }\n\n      get condition() {\n        return this.s[0] / this.s[Math.min(this.m, this.n) - 1];\n      }\n\n      get norm2() {\n        return this.s[0];\n      }\n\n      get rank() {\n        for (var t = Math.max(this.m, this.n) * this.s[0] * Number.EPSILON, r = 0, e = this.s, n = 0, i = e.length; n < i; n++) e[n] > t && r++;\n\n        return r;\n      }\n\n      get diagonal() {\n        return this.s;\n      }\n\n      get threshold() {\n        return Number.EPSILON / 2 * Math.max(this.m, this.n) * this.s[0];\n      }\n\n      get leftSingularVectors() {\n        return _.isMatrix(this.U) || (this.U = new _(this.U)), this.U;\n      }\n\n      get rightSingularVectors() {\n        return _.isMatrix(this.V) || (this.V = new _(this.V)), this.V;\n      }\n\n      get diagonalMatrix() {\n        return _.diag(this.s);\n      }\n\n    }\n\n    function f(t, r, e) {\n      var n = e ? t.rows : t.rows - 1;\n      if (r < 0 || r > n) throw new RangeError(\"Row index out of range\");\n    }\n\n    function m(t, r, e) {\n      var n = e ? t.columns : t.columns - 1;\n      if (r < 0 || r > n) throw new RangeError(\"Column index out of range\");\n    }\n\n    function g(t, r) {\n      if (r.to1DArray && (r = r.to1DArray()), r.length !== t.columns) throw new RangeError(\"vector size must be the same as the number of columns\");\n      return r;\n    }\n\n    function p(t, r) {\n      if (r.to1DArray && (r = r.to1DArray()), r.length !== t.rows) throw new RangeError(\"vector size must be the same as the number of rows\");\n      return r;\n    }\n\n    function v(t, r, e) {\n      return {\n        row: d(t, r),\n        column: w(t, e)\n      };\n    }\n\n    function d(t, r) {\n      if (\"object\" != typeof r) throw new TypeError(\"unexpected type for row indices\");\n      if (r.some(r => r < 0 || r >= t.rows)) throw new RangeError(\"row indices are out of range\");\n      return Array.isArray(r) || (r = Array.from(r)), r;\n    }\n\n    function w(t, r) {\n      if (\"object\" != typeof r) throw new TypeError(\"unexpected type for column indices\");\n      if (r.some(r => r < 0 || r >= t.columns)) throw new RangeError(\"column indices are out of range\");\n      return Array.isArray(r) || (r = Array.from(r)), r;\n    }\n\n    function y(t, r, e, n, i) {\n      if (5 !== arguments.length) throw new RangeError(\"expected 4 arguments\");\n      if (b(\"startRow\", r), b(\"endRow\", e), b(\"startColumn\", n), b(\"endColumn\", i), r > e || n > i || r < 0 || r >= t.rows || e < 0 || e >= t.rows || n < 0 || n >= t.columns || i < 0 || i >= t.columns) throw new RangeError(\"Submatrix indices are out of range\");\n    }\n\n    function b(t, r) {\n      if (\"number\" != typeof r) throw new TypeError(`${t} must be a number`);\n    }\n\n    class M extends C() {\n      constructor(t, r, e) {\n        super(), this.matrix = t, this.rows = r, this.columns = e;\n      }\n\n      static get [Symbol.species]() {\n        return _;\n      }\n\n    }\n\n    class x extends M {\n      constructor(t) {\n        super(t, t.columns, t.rows);\n      }\n\n      set(t, r, e) {\n        return this.matrix.set(r, t, e), this;\n      }\n\n      get(t, r) {\n        return this.matrix.get(r, t);\n      }\n\n    }\n\n    class S extends M {\n      constructor(t, r) {\n        super(t, 1, t.columns), this.row = r;\n      }\n\n      set(t, r, e) {\n        return this.matrix.set(this.row, r, e), this;\n      }\n\n      get(t, r) {\n        return this.matrix.get(this.row, r);\n      }\n\n    }\n\n    class E extends M {\n      constructor(t, r, e, n, i) {\n        y(t, r, e, n, i), super(t, e - r + 1, i - n + 1), this.startRow = r, this.startColumn = n;\n      }\n\n      set(t, r, e) {\n        return this.matrix.set(this.startRow + t, this.startColumn + r, e), this;\n      }\n\n      get(t, r) {\n        return this.matrix.get(this.startRow + t, this.startColumn + r);\n      }\n\n    }\n\n    class R extends M {\n      constructor(t, r, e) {\n        var n = v(t, r, e);\n        super(t, n.row.length, n.column.length), this.rowIndices = n.row, this.columnIndices = n.column;\n      }\n\n      set(t, r, e) {\n        return this.matrix.set(this.rowIndices[t], this.columnIndices[r], e), this;\n      }\n\n      get(t, r) {\n        return this.matrix.get(this.rowIndices[t], this.columnIndices[r]);\n      }\n\n    }\n\n    class k extends M {\n      constructor(t, r) {\n        super(t, (r = d(t, r)).length, t.columns), this.rowIndices = r;\n      }\n\n      set(t, r, e) {\n        return this.matrix.set(this.rowIndices[t], r, e), this;\n      }\n\n      get(t, r) {\n        return this.matrix.get(this.rowIndices[t], r);\n      }\n\n    }\n\n    class z extends M {\n      constructor(t, r) {\n        r = w(t, r), super(t, t.rows, r.length), this.columnIndices = r;\n      }\n\n      set(t, r, e) {\n        return this.matrix.set(t, this.columnIndices[r], e), this;\n      }\n\n      get(t, r) {\n        return this.matrix.get(t, this.columnIndices[r]);\n      }\n\n    }\n\n    class N extends M {\n      constructor(t, r) {\n        super(t, t.rows, 1), this.column = r;\n      }\n\n      set(t, r, e) {\n        return this.matrix.set(t, this.column, e), this;\n      }\n\n      get(t) {\n        return this.matrix.get(t, this.column);\n      }\n\n    }\n\n    class A extends M {\n      constructor(t) {\n        super(t, t.rows, t.columns);\n      }\n\n      set(t, r, e) {\n        return this.matrix.set(this.rows - t - 1, r, e), this;\n      }\n\n      get(t, r) {\n        return this.matrix.get(this.rows - t - 1, r);\n      }\n\n    }\n\n    class V extends M {\n      constructor(t) {\n        super(t, t.rows, t.columns);\n      }\n\n      set(t, r, e) {\n        return this.matrix.set(t, this.columns - r - 1, e), this;\n      }\n\n      get(t, r) {\n        return this.matrix.get(t, this.columns - r - 1);\n      }\n\n    }\n\n    function C(t) {\n      void 0 === t && (t = Object);\n\n      class r extends t {\n        static get [Symbol.species]() {\n          return this;\n        }\n\n        static from1DArray(t, r, e) {\n          if (t * r !== e.length) throw new RangeError(\"Data length does not match given dimensions\");\n\n          for (var n = new this(t, r), i = 0; i < t; i++) for (var o = 0; o < r; o++) n.set(i, o, e[i * r + o]);\n\n          return n;\n        }\n\n        static rowVector(t) {\n          for (var r = new this(1, t.length), e = 0; e < t.length; e++) r.set(0, e, t[e]);\n\n          return r;\n        }\n\n        static columnVector(t) {\n          for (var r = new this(t.length, 1), e = 0; e < t.length; e++) r.set(e, 0, t[e]);\n\n          return r;\n        }\n\n        static empty(t, r) {\n          return new this(t, r);\n        }\n\n        static zeros(t, r) {\n          return this.empty(t, r).fill(0);\n        }\n\n        static ones(t, r) {\n          return this.empty(t, r).fill(1);\n        }\n\n        static rand(t, r, e) {\n          void 0 === e && (e = Math.random);\n\n          for (var n = this.empty(t, r), i = 0; i < t; i++) for (var o = 0; o < r; o++) n.set(i, o, e());\n\n          return n;\n        }\n\n        static randInt(t, r, e, n) {\n          void 0 === e && (e = 1e3), void 0 === n && (n = Math.random);\n\n          for (var i = this.empty(t, r), o = 0; o < t; o++) for (var s = 0; s < r; s++) {\n            var a = Math.floor(n() * e);\n            i.set(o, s, a);\n          }\n\n          return i;\n        }\n\n        static eye(t, r, e) {\n          void 0 === r && (r = t), void 0 === e && (e = 1);\n\n          for (var n = Math.min(t, r), i = this.zeros(t, r), o = 0; o < n; o++) i.set(o, o, e);\n\n          return i;\n        }\n\n        static diag(t, r, e) {\n          var n = t.length;\n          void 0 === r && (r = n), void 0 === e && (e = r);\n\n          for (var i = Math.min(n, r, e), o = this.zeros(r, e), s = 0; s < i; s++) o.set(s, s, t[s]);\n\n          return o;\n        }\n\n        static min(t, r) {\n          t = this.checkMatrix(t), r = this.checkMatrix(r);\n\n          for (var e = t.rows, n = t.columns, i = new this(e, n), o = 0; o < e; o++) for (var s = 0; s < n; s++) i.set(o, s, Math.min(t.get(o, s), r.get(o, s)));\n\n          return i;\n        }\n\n        static max(t, r) {\n          t = this.checkMatrix(t), r = this.checkMatrix(r);\n\n          for (var e = t.rows, n = t.columns, i = new this(e, n), o = 0; o < e; o++) for (var s = 0; s < n; s++) i.set(o, s, Math.max(t.get(o, s), r.get(o, s)));\n\n          return i;\n        }\n\n        static checkMatrix(t) {\n          return r.isMatrix(t) ? t : new this(t);\n        }\n\n        static isMatrix(t) {\n          return null != t && \"Matrix\" === t.klass;\n        }\n\n        get size() {\n          return this.rows * this.columns;\n        }\n\n        apply(t) {\n          if (\"function\" != typeof t) throw new TypeError(\"callback must be a function\");\n\n          for (var r = this.rows, e = this.columns, n = 0; n < r; n++) for (var i = 0; i < e; i++) t.call(this, n, i);\n\n          return this;\n        }\n\n        to1DArray() {\n          for (var t = new Array(this.size), r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) t[r * this.columns + e] = this.get(r, e);\n\n          return t;\n        }\n\n        to2DArray() {\n          for (var t = new Array(this.rows), r = 0; r < this.rows; r++) {\n            t[r] = new Array(this.columns);\n\n            for (var e = 0; e < this.columns; e++) t[r][e] = this.get(r, e);\n          }\n\n          return t;\n        }\n\n        isRowVector() {\n          return 1 === this.rows;\n        }\n\n        isColumnVector() {\n          return 1 === this.columns;\n        }\n\n        isVector() {\n          return 1 === this.rows || 1 === this.columns;\n        }\n\n        isSquare() {\n          return this.rows === this.columns;\n        }\n\n        isSymmetric() {\n          if (this.isSquare()) {\n            for (var t = 0; t < this.rows; t++) for (var r = 0; r <= t; r++) if (this.get(t, r) !== this.get(r, t)) return !1;\n\n            return !0;\n          }\n\n          return !1;\n        }\n\n        set(t, r, e) {\n          throw new Error(\"set method is unimplemented\");\n        }\n\n        get(t, r) {\n          throw new Error(\"get method is unimplemented\");\n        }\n\n        repeat(t, r) {\n          t = t || 1, r = r || 1;\n\n          for (var e = new this.constructor[Symbol.species](this.rows * t, this.columns * r), n = 0; n < t; n++) for (var i = 0; i < r; i++) e.setSubMatrix(this, this.rows * n, this.columns * i);\n\n          return e;\n        }\n\n        fill(t) {\n          for (var r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.set(r, e, t);\n\n          return this;\n        }\n\n        neg() {\n          return this.mulS(-1);\n        }\n\n        getRow(t) {\n          f(this, t);\n\n          for (var r = new Array(this.columns), e = 0; e < this.columns; e++) r[e] = this.get(t, e);\n\n          return r;\n        }\n\n        getRowVector(t) {\n          return this.constructor.rowVector(this.getRow(t));\n        }\n\n        setRow(t, r) {\n          f(this, t), r = g(this, r);\n\n          for (var e = 0; e < this.columns; e++) this.set(t, e, r[e]);\n\n          return this;\n        }\n\n        swapRows(t, r) {\n          f(this, t), f(this, r);\n\n          for (var e = 0; e < this.columns; e++) {\n            var n = this.get(t, e);\n            this.set(t, e, this.get(r, e)), this.set(r, e, n);\n          }\n\n          return this;\n        }\n\n        getColumn(t) {\n          m(this, t);\n\n          for (var r = new Array(this.rows), e = 0; e < this.rows; e++) r[e] = this.get(e, t);\n\n          return r;\n        }\n\n        getColumnVector(t) {\n          return this.constructor.columnVector(this.getColumn(t));\n        }\n\n        setColumn(t, r) {\n          m(this, t), r = p(this, r);\n\n          for (var e = 0; e < this.rows; e++) this.set(e, t, r[e]);\n\n          return this;\n        }\n\n        swapColumns(t, r) {\n          m(this, t), m(this, r);\n\n          for (var e = 0; e < this.rows; e++) {\n            var n = this.get(e, t);\n            this.set(e, t, this.get(e, r)), this.set(e, r, n);\n          }\n\n          return this;\n        }\n\n        addRowVector(t) {\n          t = g(this, t);\n\n          for (var r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.set(r, e, this.get(r, e) + t[e]);\n\n          return this;\n        }\n\n        subRowVector(t) {\n          t = g(this, t);\n\n          for (var r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.set(r, e, this.get(r, e) - t[e]);\n\n          return this;\n        }\n\n        mulRowVector(t) {\n          t = g(this, t);\n\n          for (var r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.set(r, e, this.get(r, e) * t[e]);\n\n          return this;\n        }\n\n        divRowVector(t) {\n          t = g(this, t);\n\n          for (var r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.set(r, e, this.get(r, e) / t[e]);\n\n          return this;\n        }\n\n        addColumnVector(t) {\n          t = p(this, t);\n\n          for (var r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.set(r, e, this.get(r, e) + t[r]);\n\n          return this;\n        }\n\n        subColumnVector(t) {\n          t = p(this, t);\n\n          for (var r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.set(r, e, this.get(r, e) - t[r]);\n\n          return this;\n        }\n\n        mulColumnVector(t) {\n          t = p(this, t);\n\n          for (var r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.set(r, e, this.get(r, e) * t[r]);\n\n          return this;\n        }\n\n        divColumnVector(t) {\n          t = p(this, t);\n\n          for (var r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.set(r, e, this.get(r, e) / t[r]);\n\n          return this;\n        }\n\n        mulRow(t, r) {\n          f(this, t);\n\n          for (var e = 0; e < this.columns; e++) this.set(t, e, this.get(t, e) * r);\n\n          return this;\n        }\n\n        mulColumn(t, r) {\n          m(this, t);\n\n          for (var e = 0; e < this.rows; e++) this.set(e, t, this.get(e, t) * r);\n\n          return this;\n        }\n\n        max() {\n          for (var t = this.get(0, 0), r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.get(r, e) > t && (t = this.get(r, e));\n\n          return t;\n        }\n\n        maxIndex() {\n          for (var t = this.get(0, 0), r = [0, 0], e = 0; e < this.rows; e++) for (var n = 0; n < this.columns; n++) this.get(e, n) > t && (t = this.get(e, n), r[0] = e, r[1] = n);\n\n          return r;\n        }\n\n        min() {\n          for (var t = this.get(0, 0), r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) this.get(r, e) < t && (t = this.get(r, e));\n\n          return t;\n        }\n\n        minIndex() {\n          for (var t = this.get(0, 0), r = [0, 0], e = 0; e < this.rows; e++) for (var n = 0; n < this.columns; n++) this.get(e, n) < t && (t = this.get(e, n), r[0] = e, r[1] = n);\n\n          return r;\n        }\n\n        maxRow(t) {\n          f(this, t);\n\n          for (var r = this.get(t, 0), e = 1; e < this.columns; e++) this.get(t, e) > r && (r = this.get(t, e));\n\n          return r;\n        }\n\n        maxRowIndex(t) {\n          f(this, t);\n\n          for (var r = this.get(t, 0), e = [t, 0], n = 1; n < this.columns; n++) this.get(t, n) > r && (r = this.get(t, n), e[1] = n);\n\n          return e;\n        }\n\n        minRow(t) {\n          f(this, t);\n\n          for (var r = this.get(t, 0), e = 1; e < this.columns; e++) this.get(t, e) < r && (r = this.get(t, e));\n\n          return r;\n        }\n\n        minRowIndex(t) {\n          f(this, t);\n\n          for (var r = this.get(t, 0), e = [t, 0], n = 1; n < this.columns; n++) this.get(t, n) < r && (r = this.get(t, n), e[1] = n);\n\n          return e;\n        }\n\n        maxColumn(t) {\n          m(this, t);\n\n          for (var r = this.get(0, t), e = 1; e < this.rows; e++) this.get(e, t) > r && (r = this.get(e, t));\n\n          return r;\n        }\n\n        maxColumnIndex(t) {\n          m(this, t);\n\n          for (var r = this.get(0, t), e = [0, t], n = 1; n < this.rows; n++) this.get(n, t) > r && (r = this.get(n, t), e[0] = n);\n\n          return e;\n        }\n\n        minColumn(t) {\n          m(this, t);\n\n          for (var r = this.get(0, t), e = 1; e < this.rows; e++) this.get(e, t) < r && (r = this.get(e, t));\n\n          return r;\n        }\n\n        minColumnIndex(t) {\n          m(this, t);\n\n          for (var r = this.get(0, t), e = [0, t], n = 1; n < this.rows; n++) this.get(n, t) < r && (r = this.get(n, t), e[0] = n);\n\n          return e;\n        }\n\n        diag() {\n          for (var t = Math.min(this.rows, this.columns), r = new Array(t), e = 0; e < t; e++) r[e] = this.get(e, e);\n\n          return r;\n        }\n\n        sum(t) {\n          switch (t) {\n            case \"row\":\n              return function (t) {\n                for (var r = _.zeros(t.rows, 1), e = 0; e < t.rows; ++e) for (var n = 0; n < t.columns; ++n) r.set(e, 0, r.get(e, 0) + t.get(e, n));\n\n                return r;\n              }(this);\n\n            case \"column\":\n              return function (t) {\n                for (var r = _.zeros(1, t.columns), e = 0; e < t.rows; ++e) for (var n = 0; n < t.columns; ++n) r.set(0, n, r.get(0, n) + t.get(e, n));\n\n                return r;\n              }(this);\n\n            default:\n              return function (t) {\n                for (var r = 0, e = 0; e < t.rows; e++) for (var n = 0; n < t.columns; n++) r += t.get(e, n);\n\n                return r;\n              }(this);\n          }\n        }\n\n        mean() {\n          return this.sum() / this.size;\n        }\n\n        prod() {\n          for (var t = 1, r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) t *= this.get(r, e);\n\n          return t;\n        }\n\n        norm(t = \"frobenius\") {\n          var r = 0;\n          if (\"max\" === t) return this.max();\n\n          if (\"frobenius\" === t) {\n            for (var e = 0; e < this.rows; e++) for (var n = 0; n < this.columns; n++) r += this.get(e, n) * this.get(e, n);\n\n            return Math.sqrt(r);\n          }\n\n          throw new RangeError(`unknown norm type: ${t}`);\n        }\n\n        cumulativeSum() {\n          for (var t = 0, r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) t += this.get(r, e), this.set(r, e, t);\n\n          return this;\n        }\n\n        dot(t) {\n          r.isMatrix(t) && (t = t.to1DArray());\n          var e = this.to1DArray();\n          if (e.length !== t.length) throw new RangeError(\"vectors do not have the same size\");\n\n          for (var n = 0, i = 0; i < e.length; i++) n += e[i] * t[i];\n\n          return n;\n        }\n\n        mmul(t) {\n          t = this.constructor.checkMatrix(t), this.columns !== t.rows && console.warn(\"Number of columns of left matrix are not equal to number of rows of right matrix.\");\n\n          for (var r = this.rows, e = this.columns, n = t.columns, i = new this.constructor[Symbol.species](r, n), o = new Array(e), s = 0; s < n; s++) {\n            for (var a = 0; a < e; a++) o[a] = t.get(a, s);\n\n            for (var h = 0; h < r; h++) {\n              var u = 0;\n\n              for (a = 0; a < e; a++) u += this.get(h, a) * o[a];\n\n              i.set(h, s, u);\n            }\n          }\n\n          return i;\n        }\n\n        strassen2x2(t) {\n          var r = new this.constructor[Symbol.species](2, 2);\n          const e = this.get(0, 0),\n                n = t.get(0, 0),\n                i = this.get(0, 1),\n                o = t.get(0, 1),\n                s = this.get(1, 0),\n                a = t.get(1, 0),\n                h = this.get(1, 1),\n                u = t.get(1, 1),\n                l = (e + h) * (n + u),\n                c = (s + h) * n,\n                f = e * (o - u),\n                m = h * (a - n),\n                g = (e + i) * u,\n                p = l + m - g + (i - h) * (a + u),\n                v = f + g,\n                d = c + m,\n                w = l - c + f + (s - e) * (n + o);\n          return r.set(0, 0, p), r.set(0, 1, v), r.set(1, 0, d), r.set(1, 1, w), r;\n        }\n\n        strassen3x3(t) {\n          var r = new this.constructor[Symbol.species](3, 3);\n\n          const e = this.get(0, 0),\n                n = this.get(0, 1),\n                i = this.get(0, 2),\n                o = this.get(1, 0),\n                s = this.get(1, 1),\n                a = this.get(1, 2),\n                h = this.get(2, 0),\n                u = this.get(2, 1),\n                l = this.get(2, 2),\n                c = t.get(0, 0),\n                f = t.get(0, 1),\n                m = t.get(0, 2),\n                g = t.get(1, 0),\n                p = t.get(1, 1),\n                v = t.get(1, 2),\n                d = t.get(2, 0),\n                w = t.get(2, 1),\n                y = t.get(2, 2),\n                b = (e - o) * (-f + p),\n                M = (-e + o + s) * (c - f + p),\n                x = (o + s) * (-c + f),\n                S = e * c,\n                E = (-e + h + u) * (c - m + v),\n                R = (-e + h) * (m - v),\n                k = (h + u) * (-c + m),\n                z = (-i + u + l) * (p + d - w),\n                N = (i - l) * (p - w),\n                A = i * d,\n                V = (u + l) * (-d + w),\n                C = (-i + s + a) * (v + d - y),\n                _ = (i - a) * (v - y),\n                P = (s + a) * (-d + y),\n                j = S + A + n * g,\n                I = (e + n + i - o - s - u - l) * p + M + x + S + z + A + V,\n                O = S + E + k + (e + n + i - s - a - h - u) * v + A + C + P,\n                D = b + s * (-c + f + g - p - v - d + y) + M + S + A + C + _,\n                L = b + M + x + S + a * w,\n                T = A + C + _ + P + o * m,\n                F = S + E + R + u * (-c + m + g - p - v - d + w) + z + N + A,\n                q = z + N + A + V + h * f,\n                U = S + E + R + k + l * y;\n\n          return r.set(0, 0, j), r.set(0, 1, I), r.set(0, 2, O), r.set(1, 0, D), r.set(1, 1, L), r.set(1, 2, T), r.set(2, 0, F), r.set(2, 1, q), r.set(2, 2, U), r;\n        }\n\n        mmulStrassen(t) {\n          var e = this.clone(),\n              n = e.rows,\n              i = e.columns,\n              o = t.rows,\n              s = t.columns;\n\n          function a(t, e, n) {\n            var i = t.rows,\n                o = t.columns;\n            if (i === e && o === n) return t;\n            var s = r.zeros(e, n);\n            return s = s.setSubMatrix(t, 0, 0);\n          }\n\n          i !== o && console.warn(`Multiplying ${n} x ${i} and ${o} x ${s} matrix: dimensions do not match.`);\n          var h = Math.max(n, o),\n              u = Math.max(i, s);\n          return function t(e, n, i, o) {\n            if (i <= 512 || o <= 512) return e.mmul(n);\n            i % 2 == 1 && o % 2 == 1 ? (e = a(e, i + 1, o + 1), n = a(n, i + 1, o + 1)) : i % 2 == 1 ? (e = a(e, i + 1, o), n = a(n, i + 1, o)) : o % 2 == 1 && (e = a(e, i, o + 1), n = a(n, i, o + 1));\n            var s = parseInt(e.rows / 2, 10),\n                h = parseInt(e.columns / 2, 10),\n                u = e.subMatrix(0, s - 1, 0, h - 1),\n                l = n.subMatrix(0, s - 1, 0, h - 1),\n                c = e.subMatrix(0, s - 1, h, e.columns - 1),\n                f = n.subMatrix(0, s - 1, h, n.columns - 1),\n                m = e.subMatrix(s, e.rows - 1, 0, h - 1),\n                g = n.subMatrix(s, n.rows - 1, 0, h - 1),\n                p = e.subMatrix(s, e.rows - 1, h, e.columns - 1),\n                v = n.subMatrix(s, n.rows - 1, h, n.columns - 1),\n                d = t(r.add(u, p), r.add(l, v), s, h),\n                w = t(r.add(m, p), l, s, h),\n                y = t(u, r.sub(f, v), s, h),\n                b = t(p, r.sub(g, l), s, h),\n                M = t(r.add(u, c), v, s, h),\n                x = t(r.sub(m, u), r.add(l, f), s, h),\n                S = t(r.sub(c, p), r.add(g, v), s, h),\n                E = r.add(d, b);\n            E.sub(M), E.add(S);\n            var R = r.add(y, M),\n                k = r.add(w, b),\n                z = r.sub(d, w);\n            z.add(y), z.add(x);\n            var N = r.zeros(2 * E.rows, 2 * E.columns);\n            return (N = (N = (N = (N = N.setSubMatrix(E, 0, 0)).setSubMatrix(R, E.rows, 0)).setSubMatrix(k, 0, E.columns)).setSubMatrix(z, E.rows, E.columns)).subMatrix(0, i - 1, 0, o - 1);\n          }(e = a(e, h, u), t = a(t, h, u), h, u);\n        }\n\n        scaleRows(t, r) {\n          if ((t = void 0 === t ? 0 : t) >= (r = void 0 === r ? 1 : r)) throw new RangeError(\"min should be strictly smaller than max\");\n\n          for (var e = this.constructor.empty(this.rows, this.columns), n = 0; n < this.rows; n++) {\n            var i = a(this.getRow(n), {\n              min: t,\n              max: r\n            });\n            e.setRow(n, i);\n          }\n\n          return e;\n        }\n\n        scaleColumns(t, r) {\n          if ((t = void 0 === t ? 0 : t) >= (r = void 0 === r ? 1 : r)) throw new RangeError(\"min should be strictly smaller than max\");\n\n          for (var e = this.constructor.empty(this.rows, this.columns), n = 0; n < this.columns; n++) {\n            var i = a(this.getColumn(n), {\n              min: t,\n              max: r\n            });\n            e.setColumn(n, i);\n          }\n\n          return e;\n        }\n\n        kroneckerProduct(t) {\n          t = this.constructor.checkMatrix(t);\n\n          for (var r = this.rows, e = this.columns, n = t.rows, i = t.columns, o = new this.constructor[Symbol.species](r * n, e * i), s = 0; s < r; s++) for (var a = 0; a < e; a++) for (var h = 0; h < n; h++) for (var u = 0; u < i; u++) o[n * s + h][i * a + u] = this.get(s, a) * t.get(h, u);\n\n          return o;\n        }\n\n        transpose() {\n          for (var t = new this.constructor[Symbol.species](this.columns, this.rows), r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) t.set(e, r, this.get(r, e));\n\n          return t;\n        }\n\n        sortRows(t) {\n          void 0 === t && (t = e);\n\n          for (var r = 0; r < this.rows; r++) this.setRow(r, this.getRow(r).sort(t));\n\n          return this;\n        }\n\n        sortColumns(t) {\n          void 0 === t && (t = e);\n\n          for (var r = 0; r < this.columns; r++) this.setColumn(r, this.getColumn(r).sort(t));\n\n          return this;\n        }\n\n        subMatrix(t, r, e, n) {\n          y(this, t, r, e, n);\n\n          for (var i = new this.constructor[Symbol.species](r - t + 1, n - e + 1), o = t; o <= r; o++) for (var s = e; s <= n; s++) i[o - t][s - e] = this.get(o, s);\n\n          return i;\n        }\n\n        subMatrixRow(t, r, e) {\n          if (void 0 === r && (r = 0), void 0 === e && (e = this.columns - 1), r > e || r < 0 || r >= this.columns || e < 0 || e >= this.columns) throw new RangeError(\"Argument out of range\");\n\n          for (var n = new this.constructor[Symbol.species](t.length, e - r + 1), i = 0; i < t.length; i++) for (var o = r; o <= e; o++) {\n            if (t[i] < 0 || t[i] >= this.rows) throw new RangeError(`Row index out of range: ${t[i]}`);\n            n.set(i, o - r, this.get(t[i], o));\n          }\n\n          return n;\n        }\n\n        subMatrixColumn(t, r, e) {\n          if (void 0 === r && (r = 0), void 0 === e && (e = this.rows - 1), r > e || r < 0 || r >= this.rows || e < 0 || e >= this.rows) throw new RangeError(\"Argument out of range\");\n\n          for (var n = new this.constructor[Symbol.species](e - r + 1, t.length), i = 0; i < t.length; i++) for (var o = r; o <= e; o++) {\n            if (t[i] < 0 || t[i] >= this.columns) throw new RangeError(`Column index out of range: ${t[i]}`);\n            n.set(o - r, i, this.get(o, t[i]));\n          }\n\n          return n;\n        }\n\n        setSubMatrix(t, r, e) {\n          y(this, r, r + (t = this.constructor.checkMatrix(t)).rows - 1, e, e + t.columns - 1);\n\n          for (var n = 0; n < t.rows; n++) for (var i = 0; i < t.columns; i++) this[r + n][e + i] = t.get(n, i);\n\n          return this;\n        }\n\n        selection(t, r) {\n          for (var e = v(this, t, r), n = new this.constructor[Symbol.species](t.length, r.length), i = 0; i < e.row.length; i++) for (var o = e.row[i], s = 0; s < e.column.length; s++) {\n            var a = e.column[s];\n            n[i][s] = this.get(o, a);\n          }\n\n          return n;\n        }\n\n        trace() {\n          for (var t = Math.min(this.rows, this.columns), r = 0, e = 0; e < t; e++) r += this.get(e, e);\n\n          return r;\n        }\n\n        transposeView() {\n          return new x(this);\n        }\n\n        rowView(t) {\n          return f(this, t), new S(this, t);\n        }\n\n        columnView(t) {\n          return m(this, t), new N(this, t);\n        }\n\n        flipRowView() {\n          return new A(this);\n        }\n\n        flipColumnView() {\n          return new V(this);\n        }\n\n        subMatrixView(t, r, e, n) {\n          return new E(this, t, r, e, n);\n        }\n\n        selectionView(t, r) {\n          return new R(this, t, r);\n        }\n\n        rowSelectionView(t) {\n          return new k(this, t);\n        }\n\n        columnSelectionView(t) {\n          return new z(this, t);\n        }\n\n        det() {\n          var t, r, e, n, i, o;\n          if (this.isSquare()) return 2 === this.columns ? (t = this.get(0, 0), r = this.get(0, 1), e = this.get(1, 0), t * this.get(1, 1) - r * e) : 3 === this.columns ? (n = this.selectionView([1, 2], [1, 2]), i = this.selectionView([1, 2], [0, 2]), o = this.selectionView([1, 2], [0, 1]), t = this.get(0, 0), r = this.get(0, 1), e = this.get(0, 2), t * n.det() - r * i.det() + e * o.det()) : new h(this).determinant;\n          throw Error(\"Determinant can only be calculated for a square matrix.\");\n        }\n\n        pseudoInverse(t) {\n          void 0 === t && (t = Number.EPSILON);\n\n          for (var r = new c(this, {\n            autoTranspose: !0\n          }), e = r.leftSingularVectors, n = r.rightSingularVectors, i = r.diagonal, o = 0; o < i.length; o++) Math.abs(i[o]) > t ? i[o] = 1 / i[o] : i[o] = 0;\n\n          return i = this.constructor[Symbol.species].diag(i), n.mmul(i.mmul(e.transposeView()));\n        }\n\n        clone() {\n          for (var t = new this.constructor[Symbol.species](this.rows, this.columns), r = 0; r < this.rows; r++) for (var e = 0; e < this.columns; e++) t.set(r, e, this.get(r, e));\n\n          return t;\n        }\n\n      }\n\n      function e(t, r) {\n        return t - r;\n      }\n\n      r.prototype.klass = \"Matrix\", r.random = r.rand, r.diagonal = r.diag, r.prototype.diagonal = r.prototype.diag, r.identity = r.eye, r.prototype.negate = r.prototype.neg, r.prototype.tensorProduct = r.prototype.kroneckerProduct, r.prototype.determinant = r.prototype.det;\n      var n,\n          i = \"\\n(function %name%(matrix, %args%) {\\n    var newMatrix = new this[Symbol.species](matrix);\\n    return newMatrix.%name%(%args%);\\n})\\n\",\n          o = eval;\n\n      for (var s of [[\"+\", \"add\"], [\"-\", \"sub\", \"subtract\"], [\"*\", \"mul\", \"multiply\"], [\"/\", \"div\", \"divide\"], [\"%\", \"mod\", \"modulus\"], [\"&\", \"and\"], [\"|\", \"or\"], [\"^\", \"xor\"], [\"<<\", \"leftShift\"], [\">>\", \"signPropagatingRightShift\"], [\">>>\", \"rightShift\", \"zeroFillRightShift\"]]) {\n        var u = o($(\"\\n(function %name%(value) {\\n    if (typeof value === 'number') return this.%name%S(value);\\n    return this.%name%M(value);\\n})\\n\", {\n          name: s[1],\n          op: s[0]\n        })),\n            l = o($(\"\\n(function %name%S(value) {\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, this.get(i, j) %op% value);\\n        }\\n    }\\n    return this;\\n})\\n\", {\n          name: `${s[1]}S`,\n          op: s[0]\n        })),\n            d = o($(\"\\n(function %name%M(matrix) {\\n    matrix = this.constructor.checkMatrix(matrix);\\n    if (this.rows !== matrix.rows ||\\n        this.columns !== matrix.columns) {\\n        throw new RangeError('Matrices dimensions must be equal');\\n    }\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, this.get(i, j) %op% matrix.get(i, j));\\n        }\\n    }\\n    return this;\\n})\\n\", {\n          name: `${s[1]}M`,\n          op: s[0]\n        })),\n            w = o($(\"\\n(function %name%(matrix, value) {\\n    var newMatrix = new this[Symbol.species](matrix);\\n    return newMatrix.%name%(value);\\n})\\n\", {\n          name: s[1]\n        }));\n\n        for (n = 1; n < s.length; n++) r.prototype[s[n]] = u, r.prototype[`${s[n]}S`] = l, r.prototype[`${s[n]}M`] = d, r[s[n]] = w;\n      }\n\n      var b = [[\"~\", \"not\"]];\n\n      for (var M of ([\"abs\", \"acos\", \"acosh\", \"asin\", \"asinh\", \"atan\", \"atanh\", \"cbrt\", \"ceil\", \"clz32\", \"cos\", \"cosh\", \"exp\", \"expm1\", \"floor\", \"fround\", \"log\", \"log1p\", \"log10\", \"log2\", \"round\", \"sign\", \"sin\", \"sinh\", \"sqrt\", \"tan\", \"tanh\", \"trunc\"].forEach(function (t) {\n        b.push([`Math.${t}`, t]);\n      }), b)) {\n        var C = o($(\"\\n(function %name%() {\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, %method%(this.get(i, j)));\\n        }\\n    }\\n    return this;\\n})\\n\", {\n          name: M[1],\n          method: M[0]\n        })),\n            P = o($(\"\\n(function %name%(matrix) {\\n    var newMatrix = new this[Symbol.species](matrix);\\n    return newMatrix.%name%();\\n})\\n\", {\n          name: M[1]\n        }));\n\n        for (n = 1; n < M.length; n++) r.prototype[M[n]] = C, r[M[n]] = P;\n      }\n\n      for (var j of [[\"Math.pow\", 1, \"pow\"]]) {\n        var I = \"arg0\";\n\n        for (n = 1; n < j[1]; n++) I += `, arg${n}`;\n\n        if (1 !== j[1]) {\n          var O = o($(\"\\n(function %name%(%args%) {\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, %method%(this.get(i, j), %args%));\\n        }\\n    }\\n    return this;\\n})\\n\", {\n            name: j[2],\n            method: j[0],\n            args: I\n          })),\n              D = o($(i, {\n            name: j[2],\n            args: I\n          }));\n\n          for (n = 2; n < j.length; n++) r.prototype[j[n]] = O, r[j[n]] = D;\n        } else {\n          var L = {\n            name: j[2],\n            args: I,\n            method: j[0]\n          },\n              T = o($(\"\\n(function %name%(value) {\\n    if (typeof value === 'number') return this.%name%S(value);\\n    return this.%name%M(value);\\n})\\n\", L)),\n              F = o($(\"\\n(function %name%S(value) {\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, %method%(this.get(i, j), value));\\n        }\\n    }\\n    return this;\\n})\\n\", L)),\n              q = o($(\"\\n(function %name%M(matrix) {\\n    matrix = this.constructor.checkMatrix(matrix);\\n    if (this.rows !== matrix.rows ||\\n        this.columns !== matrix.columns) {\\n        throw new RangeError('Matrices dimensions must be equal');\\n    }\\n    for (var i = 0; i < this.rows; i++) {\\n        for (var j = 0; j < this.columns; j++) {\\n            this.set(i, j, %method%(this.get(i, j), matrix.get(i, j)));\\n        }\\n    }\\n    return this;\\n})\\n\", L)),\n              U = o($(\"\\n(function %name%(matrix, %args%) {\\n    var newMatrix = new this[Symbol.species](matrix);\\n    return newMatrix.%name%(%args%);\\n})\\n\", L));\n\n          for (n = 2; n < j.length; n++) r.prototype[j[n]] = T, r.prototype[`${j[n]}M`] = q, r.prototype[`${j[n]}S`] = F, r[j[n]] = U;\n        }\n      }\n\n      function $(t, r) {\n        for (var e in r) t = t.replace(new RegExp(`%${e}%`, \"g\"), r[e]);\n\n        return t;\n      }\n\n      return r;\n    }\n\n    class _ extends C(Array) {\n      constructor(t, r) {\n        var e;\n        if (1 === arguments.length && \"number\" == typeof t) return new Array(t);\n        if (_.isMatrix(t)) return t.clone();\n\n        if (Number.isInteger(t) && t > 0) {\n          if (super(t), !(Number.isInteger(r) && r > 0)) throw new TypeError(\"nColumns must be a positive integer\");\n\n          for (e = 0; e < t; e++) this[e] = new Array(r);\n        } else {\n          if (!Array.isArray(t)) throw new TypeError(\"First argument must be a positive number or an array\");\n          {\n            const n = t;\n            if (t = n.length, \"number\" != typeof (r = n[0].length) || 0 === r) throw new TypeError(\"Data must be a 2D array with at least one element\");\n\n            for (super(t), e = 0; e < t; e++) {\n              if (n[e].length !== r) throw new RangeError(\"Inconsistent array dimensions\");\n              this[e] = [].concat(n[e]);\n            }\n          }\n        }\n\n        return this.rows = t, this.columns = r, this;\n      }\n\n      set(t, r, e) {\n        return this[t][r] = e, this;\n      }\n\n      get(t, r) {\n        return this[t][r];\n      }\n\n      removeRow(t) {\n        if (f(this, t), 1 === this.rows) throw new RangeError(\"A matrix cannot have less than one row\");\n        return this.splice(t, 1), this.rows -= 1, this;\n      }\n\n      addRow(t, r) {\n        return void 0 === r && (r = t, t = this.rows), f(this, t, !0), r = g(this, r), this.splice(t, 0, r), this.rows += 1, this;\n      }\n\n      removeColumn(t) {\n        if (m(this, t), 1 === this.columns) throw new RangeError(\"A matrix cannot have less than one column\");\n\n        for (var r = 0; r < this.rows; r++) this[r].splice(t, 1);\n\n        return this.columns -= 1, this;\n      }\n\n      addColumn(t, r) {\n        void 0 === r && (r = t, t = this.columns), m(this, t, !0), r = p(this, r);\n\n        for (var e = 0; e < this.rows; e++) this[e].splice(t, 0, r[e]);\n\n        return this.columns += 1, this;\n      }\n\n    }\n\n    class P extends C() {\n      constructor(t, r = {}) {\n        const {\n          rows: e = 1\n        } = r;\n        if (t.length % e != 0) throw new Error(\"the data length is not divisible by the number of rows\");\n        super(), this.rows = e, this.columns = t.length / e, this.data = t;\n      }\n\n      set(t, r, e) {\n        var n = this._calculateIndex(t, r);\n\n        return this.data[n] = e, this;\n      }\n\n      get(t, r) {\n        var e = this._calculateIndex(t, r);\n\n        return this.data[e];\n      }\n\n      _calculateIndex(t, r) {\n        return t * this.columns + r;\n      }\n\n      static get [Symbol.species]() {\n        return _;\n      }\n\n    }\n\n    class j extends C() {\n      constructor(t) {\n        super(), this.data = t, this.rows = t.length, this.columns = t[0].length;\n      }\n\n      set(t, r, e) {\n        return this.data[t][r] = e, this;\n      }\n\n      get(t, r) {\n        return this.data[t][r];\n      }\n\n      static get [Symbol.species]() {\n        return _;\n      }\n\n    }\n\n    function I(t, r) {\n      if (Array.isArray(t)) return t[0] && Array.isArray(t[0]) ? new j(t) : new P(t, r);\n      throw new Error(\"the argument is not an array\");\n    }\n\n    class O {\n      constructor(t) {\n        var r,\n            e,\n            n,\n            i,\n            o = (t = j.checkMatrix(t)).clone(),\n            s = t.rows,\n            a = t.columns,\n            h = new Array(a);\n\n        for (n = 0; n < a; n++) {\n          var l = 0;\n\n          for (r = n; r < s; r++) l = u(l, o.get(r, n));\n\n          if (0 !== l) {\n            for (o.get(n, n) < 0 && (l = -l), r = n; r < s; r++) o.set(r, n, o.get(r, n) / l);\n\n            for (o.set(n, n, o.get(n, n) + 1), e = n + 1; e < a; e++) {\n              for (i = 0, r = n; r < s; r++) i += o.get(r, n) * o.get(r, e);\n\n              for (i = -i / o.get(n, n), r = n; r < s; r++) o.set(r, e, o.get(r, e) + i * o.get(r, n));\n            }\n          }\n\n          h[n] = -l;\n        }\n\n        this.QR = o, this.Rdiag = h;\n      }\n\n      solve(t) {\n        t = _.checkMatrix(t);\n        var r = this.QR,\n            e = r.rows;\n        if (t.rows !== e) throw new Error(\"Matrix row dimensions must agree\");\n        if (!this.isFullRank()) throw new Error(\"Matrix is rank deficient\");\n        var n,\n            i,\n            o,\n            s,\n            a = t.columns,\n            h = t.clone(),\n            u = r.columns;\n\n        for (o = 0; o < u; o++) for (i = 0; i < a; i++) {\n          for (s = 0, n = o; n < e; n++) s += r[n][o] * h[n][i];\n\n          for (s = -s / r[o][o], n = o; n < e; n++) h[n][i] += s * r[n][o];\n        }\n\n        for (o = u - 1; o >= 0; o--) {\n          for (i = 0; i < a; i++) h[o][i] /= this.Rdiag[o];\n\n          for (n = 0; n < o; n++) for (i = 0; i < a; i++) h[n][i] -= h[o][i] * r[n][o];\n        }\n\n        return h.subMatrix(0, u - 1, 0, a - 1);\n      }\n\n      isFullRank() {\n        for (var t = this.QR.columns, r = 0; r < t; r++) if (0 === this.Rdiag[r]) return !1;\n\n        return !0;\n      }\n\n      get upperTriangularMatrix() {\n        var t,\n            r,\n            e = this.QR,\n            n = e.columns,\n            i = new _(n, n);\n\n        for (t = 0; t < n; t++) for (r = 0; r < n; r++) i[t][r] = t < r ? e[t][r] : t === r ? this.Rdiag[t] : 0;\n\n        return i;\n      }\n\n      get orthogonalMatrix() {\n        var t,\n            r,\n            e,\n            n,\n            i = this.QR,\n            o = i.rows,\n            s = i.columns,\n            a = new _(o, s);\n\n        for (e = s - 1; e >= 0; e--) {\n          for (t = 0; t < o; t++) a[t][e] = 0;\n\n          for (a[e][e] = 1, r = e; r < s; r++) if (0 !== i[e][e]) {\n            for (n = 0, t = e; t < o; t++) n += i[t][e] * a[t][r];\n\n            for (n = -n / i[e][e], t = e; t < o; t++) a[t][r] += n * i[t][e];\n          }\n        }\n\n        return a;\n      }\n\n    }\n\n    function D(t, r = !1) {\n      return t = j.checkMatrix(t), r ? new c(t).inverse() : L(t, _.eye(t.rows));\n    }\n\n    function L(t, r, e = !1) {\n      return t = j.checkMatrix(t), r = j.checkMatrix(r), e ? new c(t).solve(r) : t.isSquare() ? new h(t).solve(r) : new O(t).solve(r);\n    }\n\n    function T(t, r) {\n      for (var e = [], n = 0; n < t; n++) n !== r && e.push(n);\n\n      return e;\n    }\n\n    function F(t, r, e, n = 1e-9, i = 1e-9) {\n      if (t > i) return new Array(r.rows + 1).fill(0);\n\n      for (var o = r.addRow(e, [0]), s = 0; s < o.rows; s++) Math.abs(o.get(s, 0)) < n && o.set(s, 0, 0);\n\n      return o.to1DArray();\n    }\n\n    function q(t, r = {}) {\n      const {\n        thresholdValue: e = 1e-9,\n        thresholdError: n = 1e-9\n      } = r;\n\n      for (var i = t.rows, s = new _(i, i), a = 0; a < i; a++) {\n        var h = _.columnVector(t.getRow(a)),\n            u = t.subMatrixRow(T(i, a)).transposeView(),\n            l = new c(u).solve(h),\n            f = o(_.sub(h, u.mmul(l)).abs().to1DArray());\n\n        s.setRow(a, F(f, l, a, e, n));\n      }\n\n      return s;\n    }\n\n    class U {\n      constructor(t, r = {}) {\n        const {\n          assumeSymmetric: e = !1\n        } = r;\n        if (!(t = j.checkMatrix(t)).isSquare()) throw new Error(\"Matrix is not a square matrix\");\n        var n,\n            i,\n            o = t.columns,\n            s = l(o, o, 0),\n            a = new Array(o),\n            h = new Array(o),\n            c = t;\n\n        if (!!e || t.isSymmetric()) {\n          for (n = 0; n < o; n++) for (i = 0; i < o; i++) s[n][i] = c.get(n, i);\n\n          !function (t, r, e, n) {\n            var i, o, s, a, h, u, l, c;\n\n            for (h = 0; h < t; h++) e[h] = n[t - 1][h];\n\n            for (a = t - 1; a > 0; a--) {\n              for (c = 0, s = 0, u = 0; u < a; u++) c += Math.abs(e[u]);\n\n              if (0 === c) for (r[a] = e[a - 1], h = 0; h < a; h++) e[h] = n[a - 1][h], n[a][h] = 0, n[h][a] = 0;else {\n                for (u = 0; u < a; u++) e[u] /= c, s += e[u] * e[u];\n\n                for (i = e[a - 1], o = Math.sqrt(s), i > 0 && (o = -o), r[a] = c * o, s -= i * o, e[a - 1] = i - o, h = 0; h < a; h++) r[h] = 0;\n\n                for (h = 0; h < a; h++) {\n                  for (i = e[h], n[h][a] = i, o = r[h] + n[h][h] * i, u = h + 1; u <= a - 1; u++) o += n[u][h] * e[u], r[u] += n[u][h] * i;\n\n                  r[h] = o;\n                }\n\n                for (i = 0, h = 0; h < a; h++) r[h] /= s, i += r[h] * e[h];\n\n                for (l = i / (s + s), h = 0; h < a; h++) r[h] -= l * e[h];\n\n                for (h = 0; h < a; h++) {\n                  for (i = e[h], o = r[h], u = h; u <= a - 1; u++) n[u][h] -= i * r[u] + o * e[u];\n\n                  e[h] = n[a - 1][h], n[a][h] = 0;\n                }\n              }\n              e[a] = s;\n            }\n\n            for (a = 0; a < t - 1; a++) {\n              if (n[t - 1][a] = n[a][a], n[a][a] = 1, 0 !== (s = e[a + 1])) {\n                for (u = 0; u <= a; u++) e[u] = n[u][a + 1] / s;\n\n                for (h = 0; h <= a; h++) {\n                  for (o = 0, u = 0; u <= a; u++) o += n[u][a + 1] * n[u][h];\n\n                  for (u = 0; u <= a; u++) n[u][h] -= o * e[u];\n                }\n              }\n\n              for (u = 0; u <= a; u++) n[u][a + 1] = 0;\n            }\n\n            for (h = 0; h < t; h++) e[h] = n[t - 1][h], n[t - 1][h] = 0;\n\n            n[t - 1][t - 1] = 1, r[0] = 0;\n          }(o, h, a, s), function (t, r, e, n) {\n            var i, o, s, a, h, l, c, f, m, g, p, v, d, w, y, b;\n\n            for (s = 1; s < t; s++) r[s - 1] = r[s];\n\n            r[t - 1] = 0;\n            var M = 0,\n                x = 0,\n                S = Number.EPSILON;\n\n            for (l = 0; l < t; l++) {\n              for (x = Math.max(x, Math.abs(e[l]) + Math.abs(r[l])), c = l; c < t && !(Math.abs(r[c]) <= S * x);) c++;\n\n              if (c > l) {\n                0;\n\n                do {\n                  for (1, i = e[l], f = (e[l + 1] - i) / (2 * r[l]), m = u(f, 1), f < 0 && (m = -m), e[l] = r[l] / (f + m), e[l + 1] = r[l] * (f + m), g = e[l + 1], o = i - e[l], s = l + 2; s < t; s++) e[s] -= o;\n\n                  for (M += o, f = e[c], v = p = 1, d = p, w = r[l + 1], y = 0, b = 0, s = c - 1; s >= l; s--) for (d = v, v = p, b = y, i = p * r[s], o = p * f, m = u(f, r[s]), r[s + 1] = y * m, y = r[s] / m, f = (p = f / m) * e[s] - y * i, e[s + 1] = o + y * (p * i + y * e[s]), h = 0; h < t; h++) o = n[h][s + 1], n[h][s + 1] = y * n[h][s] + p * o, n[h][s] = p * n[h][s] - y * o;\n\n                  f = -y * b * d * w * r[l] / g, r[l] = y * f, e[l] = p * f;\n                } while (Math.abs(r[l]) > S * x);\n              }\n\n              e[l] = e[l] + M, r[l] = 0;\n            }\n\n            for (s = 0; s < t - 1; s++) {\n              for (h = s, f = e[s], a = s + 1; a < t; a++) e[a] < f && (h = a, f = e[a]);\n\n              if (h !== s) for (e[h] = e[s], e[s] = f, a = 0; a < t; a++) f = n[a][s], n[a][s] = n[a][h], n[a][h] = f;\n            }\n          }(o, h, a, s);\n        } else {\n          var f = l(o, o, 0),\n              m = new Array(o);\n\n          for (i = 0; i < o; i++) for (n = 0; n < o; n++) f[n][i] = c.get(n, i);\n\n          !function (t, r, e, n) {\n            var i,\n                o,\n                s,\n                a,\n                h,\n                u,\n                l,\n                c = t - 1;\n\n            for (u = 1; u <= c - 1; u++) {\n              for (l = 0, a = u; a <= c; a++) l += Math.abs(r[a][u - 1]);\n\n              if (0 !== l) {\n                for (s = 0, a = c; a >= u; a--) e[a] = r[a][u - 1] / l, s += e[a] * e[a];\n\n                for (o = Math.sqrt(s), e[u] > 0 && (o = -o), s -= e[u] * o, e[u] = e[u] - o, h = u; h < t; h++) {\n                  for (i = 0, a = c; a >= u; a--) i += e[a] * r[a][h];\n\n                  for (i /= s, a = u; a <= c; a++) r[a][h] -= i * e[a];\n                }\n\n                for (a = 0; a <= c; a++) {\n                  for (i = 0, h = c; h >= u; h--) i += e[h] * r[a][h];\n\n                  for (i /= s, h = u; h <= c; h++) r[a][h] -= i * e[h];\n                }\n\n                e[u] = l * e[u], r[u][u - 1] = l * o;\n              }\n            }\n\n            for (a = 0; a < t; a++) for (h = 0; h < t; h++) n[a][h] = a === h ? 1 : 0;\n\n            for (u = c - 1; u >= 1; u--) if (0 !== r[u][u - 1]) {\n              for (a = u + 1; a <= c; a++) e[a] = r[a][u - 1];\n\n              for (h = u; h <= c; h++) {\n                for (o = 0, a = u; a <= c; a++) o += e[a] * n[a][h];\n\n                for (o = o / e[u] / r[u][u - 1], a = u; a <= c; a++) n[a][h] += o * e[a];\n              }\n            }\n          }(o, f, m, s), function (t, r, e, n, i) {\n            var o,\n                s,\n                a,\n                h,\n                u,\n                l,\n                c,\n                f,\n                m,\n                g,\n                p,\n                v,\n                d,\n                w,\n                y,\n                b = t - 1,\n                M = t - 1,\n                x = Number.EPSILON,\n                S = 0,\n                E = 0,\n                R = 0,\n                k = 0,\n                z = 0,\n                N = 0,\n                A = 0,\n                V = 0;\n\n            for (o = 0; o < t; o++) for ((o < 0 || o > M) && (e[o] = i[o][o], r[o] = 0), s = Math.max(o - 1, 0); s < t; s++) E += Math.abs(i[o][s]);\n\n            for (; b >= 0;) {\n              for (h = b; h > 0 && (0 === (N = Math.abs(i[h - 1][h - 1]) + Math.abs(i[h][h])) && (N = E), !(Math.abs(i[h][h - 1]) < x * N));) h--;\n\n              if (h === b) i[b][b] = i[b][b] + S, e[b] = i[b][b], r[b] = 0, b--, V = 0;else if (h === b - 1) {\n                if (c = i[b][b - 1] * i[b - 1][b], R = (i[b - 1][b - 1] - i[b][b]) / 2, k = R * R + c, A = Math.sqrt(Math.abs(k)), i[b][b] = i[b][b] + S, i[b - 1][b - 1] = i[b - 1][b - 1] + S, f = i[b][b], k >= 0) {\n                  for (A = R >= 0 ? R + A : R - A, e[b - 1] = f + A, e[b] = e[b - 1], 0 !== A && (e[b] = f - c / A), r[b - 1] = 0, r[b] = 0, f = i[b][b - 1], N = Math.abs(f) + Math.abs(A), R = f / N, k = A / N, z = Math.sqrt(R * R + k * k), R /= z, k /= z, s = b - 1; s < t; s++) A = i[b - 1][s], i[b - 1][s] = k * A + R * i[b][s], i[b][s] = k * i[b][s] - R * A;\n\n                  for (o = 0; o <= b; o++) A = i[o][b - 1], i[o][b - 1] = k * A + R * i[o][b], i[o][b] = k * i[o][b] - R * A;\n\n                  for (o = 0; o <= M; o++) A = n[o][b - 1], n[o][b - 1] = k * A + R * n[o][b], n[o][b] = k * n[o][b] - R * A;\n                } else e[b - 1] = f + R, e[b] = f + R, r[b - 1] = A, r[b] = -A;\n\n                b -= 2, V = 0;\n              } else {\n                if (f = i[b][b], m = 0, c = 0, h < b && (m = i[b - 1][b - 1], c = i[b][b - 1] * i[b - 1][b]), 10 === V) {\n                  for (S += f, o = 0; o <= b; o++) i[o][o] -= f;\n\n                  N = Math.abs(i[b][b - 1]) + Math.abs(i[b - 1][b - 2]), f = m = .75 * N, c = -.4375 * N * N;\n                }\n\n                if (30 === V && (N = (N = (m - f) / 2) * N + c) > 0) {\n                  for (N = Math.sqrt(N), m < f && (N = -N), N = f - c / ((m - f) / 2 + N), o = 0; o <= b; o++) i[o][o] -= N;\n\n                  S += N, f = m = c = .964;\n                }\n\n                for (V += 1, u = b - 2; u >= h && (A = i[u][u], R = ((z = f - A) * (N = m - A) - c) / i[u + 1][u] + i[u][u + 1], k = i[u + 1][u + 1] - A - z - N, z = i[u + 2][u + 1], N = Math.abs(R) + Math.abs(k) + Math.abs(z), R /= N, k /= N, z /= N, u !== h) && !(Math.abs(i[u][u - 1]) * (Math.abs(k) + Math.abs(z)) < x * (Math.abs(R) * (Math.abs(i[u - 1][u - 1]) + Math.abs(A) + Math.abs(i[u + 1][u + 1]))));) u--;\n\n                for (o = u + 2; o <= b; o++) i[o][o - 2] = 0, o > u + 2 && (i[o][o - 3] = 0);\n\n                for (a = u; a <= b - 1 && (w = a !== b - 1, a !== u && (R = i[a][a - 1], k = i[a + 1][a - 1], z = w ? i[a + 2][a - 1] : 0, 0 !== (f = Math.abs(R) + Math.abs(k) + Math.abs(z)) && (R /= f, k /= f, z /= f)), 0 !== f); a++) if (N = Math.sqrt(R * R + k * k + z * z), R < 0 && (N = -N), 0 !== N) {\n                  for (a !== u ? i[a][a - 1] = -N * f : h !== u && (i[a][a - 1] = -i[a][a - 1]), f = (R += N) / N, m = k / N, A = z / N, k /= R, z /= R, s = a; s < t; s++) R = i[a][s] + k * i[a + 1][s], w && (R += z * i[a + 2][s], i[a + 2][s] = i[a + 2][s] - R * A), i[a][s] = i[a][s] - R * f, i[a + 1][s] = i[a + 1][s] - R * m;\n\n                  for (o = 0; o <= Math.min(b, a + 3); o++) R = f * i[o][a] + m * i[o][a + 1], w && (R += A * i[o][a + 2], i[o][a + 2] = i[o][a + 2] - R * z), i[o][a] = i[o][a] - R, i[o][a + 1] = i[o][a + 1] - R * k;\n\n                  for (o = 0; o <= M; o++) R = f * n[o][a] + m * n[o][a + 1], w && (R += A * n[o][a + 2], n[o][a + 2] = n[o][a + 2] - R * z), n[o][a] = n[o][a] - R, n[o][a + 1] = n[o][a + 1] - R * k;\n                }\n              }\n            }\n\n            if (0 === E) return;\n\n            for (b = t - 1; b >= 0; b--) if (R = e[b], 0 === (k = r[b])) for (h = b, i[b][b] = 1, o = b - 1; o >= 0; o--) {\n              for (c = i[o][o] - R, z = 0, s = h; s <= b; s++) z += i[o][s] * i[s][b];\n\n              if (r[o] < 0) A = c, N = z;else if (h = o, 0 === r[o] ? i[o][b] = 0 !== c ? -z / c : -z / (x * E) : (f = i[o][o + 1], m = i[o + 1][o], k = (e[o] - R) * (e[o] - R) + r[o] * r[o], l = (f * N - A * z) / k, i[o][b] = l, i[o + 1][b] = Math.abs(f) > Math.abs(A) ? (-z - c * l) / f : (-N - m * l) / A), l = Math.abs(i[o][b]), x * l * l > 1) for (s = o; s <= b; s++) i[s][b] = i[s][b] / l;\n            } else if (k < 0) for (h = b - 1, Math.abs(i[b][b - 1]) > Math.abs(i[b - 1][b]) ? (i[b - 1][b - 1] = k / i[b][b - 1], i[b - 1][b] = -(i[b][b] - R) / i[b][b - 1]) : (y = $(0, -i[b - 1][b], i[b - 1][b - 1] - R, k), i[b - 1][b - 1] = y[0], i[b - 1][b] = y[1]), i[b][b - 1] = 0, i[b][b] = 1, o = b - 2; o >= 0; o--) {\n              for (g = 0, p = 0, s = h; s <= b; s++) g += i[o][s] * i[s][b - 1], p += i[o][s] * i[s][b];\n\n              if (c = i[o][o] - R, r[o] < 0) A = c, z = g, N = p;else if (h = o, 0 === r[o] ? (y = $(-g, -p, c, k), i[o][b - 1] = y[0], i[o][b] = y[1]) : (f = i[o][o + 1], m = i[o + 1][o], v = (e[o] - R) * (e[o] - R) + r[o] * r[o] - k * k, d = 2 * (e[o] - R) * k, 0 === v && 0 === d && (v = x * E * (Math.abs(c) + Math.abs(k) + Math.abs(f) + Math.abs(m) + Math.abs(A))), y = $(f * z - A * g + k * p, f * N - A * p - k * g, v, d), i[o][b - 1] = y[0], i[o][b] = y[1], Math.abs(f) > Math.abs(A) + Math.abs(k) ? (i[o + 1][b - 1] = (-g - c * i[o][b - 1] + k * i[o][b]) / f, i[o + 1][b] = (-p - c * i[o][b] - k * i[o][b - 1]) / f) : (y = $(-z - m * i[o][b - 1], -N - m * i[o][b], A, k), i[o + 1][b - 1] = y[0], i[o + 1][b] = y[1])), l = Math.max(Math.abs(i[o][b - 1]), Math.abs(i[o][b])), x * l * l > 1) for (s = o; s <= b; s++) i[s][b - 1] = i[s][b - 1] / l, i[s][b] = i[s][b] / l;\n            }\n\n            for (o = 0; o < t; o++) if (o < 0 || o > M) for (s = o; s < t; s++) n[o][s] = i[o][s];\n\n            for (s = t - 1; s >= 0; s--) for (o = 0; o <= M; o++) {\n              for (A = 0, a = 0; a <= Math.min(s, M); a++) A += n[o][a] * i[a][s];\n\n              n[o][s] = A;\n            }\n          }(o, h, a, s, f);\n        }\n\n        this.n = o, this.e = h, this.d = a, this.V = s;\n      }\n\n      get realEigenvalues() {\n        return this.d;\n      }\n\n      get imaginaryEigenvalues() {\n        return this.e;\n      }\n\n      get eigenvectorMatrix() {\n        return _.isMatrix(this.V) || (this.V = new _(this.V)), this.V;\n      }\n\n      get diagonalMatrix() {\n        var t,\n            r,\n            e = this.n,\n            n = this.e,\n            i = this.d,\n            o = new _(e, e);\n\n        for (t = 0; t < e; t++) {\n          for (r = 0; r < e; r++) o[t][r] = 0;\n\n          o[t][t] = i[t], n[t] > 0 ? o[t][t + 1] = n[t] : n[t] < 0 && (o[t][t - 1] = n[t]);\n        }\n\n        return o;\n      }\n\n    }\n\n    function $(t, r, e, n) {\n      var i, o;\n      return Math.abs(e) > Math.abs(n) ? [(t + (i = n / e) * r) / (o = e + i * n), (r - i * t) / o] : [((i = e / n) * t + r) / (o = n + i * e), (i * r - t) / o];\n    }\n\n    class Q {\n      constructor(t) {\n        if (!(t = j.checkMatrix(t)).isSymmetric()) throw new Error(\"Matrix is not symmetric\");\n        var r,\n            e,\n            n,\n            i = t,\n            o = i.rows,\n            s = new _(o, o),\n            a = !0;\n\n        for (e = 0; e < o; e++) {\n          var h = s[e],\n              u = 0;\n\n          for (n = 0; n < e; n++) {\n            var l = s[n],\n                c = 0;\n\n            for (r = 0; r < n; r++) c += l[r] * h[r];\n\n            h[n] = c = (i.get(e, n) - c) / s[n][n], u += c * c;\n          }\n\n          for (a &= (u = i.get(e, e) - u) > 0, s[e][e] = Math.sqrt(Math.max(u, 0)), n = e + 1; n < o; n++) s[e][n] = 0;\n        }\n\n        if (!a) throw new Error(\"Matrix is not positive definite\");\n        this.L = s;\n      }\n\n      solve(t) {\n        t = j.checkMatrix(t);\n        var r = this.L,\n            e = r.rows;\n        if (t.rows !== e) throw new Error(\"Matrix dimensions do not match\");\n        var n,\n            i,\n            o,\n            s = t.columns,\n            a = t.clone();\n\n        for (o = 0; o < e; o++) for (i = 0; i < s; i++) {\n          for (n = 0; n < o; n++) a[o][i] -= a[n][i] * r[o][n];\n\n          a[o][i] /= r[o][o];\n        }\n\n        for (o = e - 1; o >= 0; o--) for (i = 0; i < s; i++) {\n          for (n = o + 1; n < e; n++) a[o][i] -= a[n][i] * r[n][o];\n\n          a[o][i] /= r[o][o];\n        }\n\n        return a;\n      }\n\n      get lowerTriangularMatrix() {\n        return this.L;\n      }\n\n    }\n\n    e.d(r, \"default\", function () {\n      return _;\n    }), e.d(r, \"Matrix\", function () {\n      return _;\n    }), e.d(r, \"abstractMatrix\", function () {\n      return C;\n    }), e.d(r, \"wrap\", function () {\n      return I;\n    }), e.d(r, \"WrapperMatrix2D\", function () {\n      return j;\n    }), e.d(r, \"WrapperMatrix1D\", function () {\n      return P;\n    }), e.d(r, \"solve\", function () {\n      return L;\n    }), e.d(r, \"inverse\", function () {\n      return D;\n    }), e.d(r, \"linearDependencies\", function () {\n      return q;\n    }), e.d(r, \"SingularValueDecomposition\", function () {\n      return c;\n    }), e.d(r, \"SVD\", function () {\n      return c;\n    }), e.d(r, \"EigenvalueDecomposition\", function () {\n      return U;\n    }), e.d(r, \"EVD\", function () {\n      return U;\n    }), e.d(r, \"CholeskyDecomposition\", function () {\n      return Q;\n    }), e.d(r, \"CHO\", function () {\n      return Q;\n    }), e.d(r, \"LuDecomposition\", function () {\n      return h;\n    }), e.d(r, \"LU\", function () {\n      return h;\n    }), e.d(r, \"QrDecomposition\", function () {\n      return O;\n    }), e.d(r, \"QR\", function () {\n      return O;\n    });\n  }]);\n});";

/* eslint-env worker */

/* eslint no-restricted-globals: 1 */
var worker = function worker() {
  var umap;

  var error = function error(message) {
    return {
      error: new Error(message)
    };
  };

  var create = function create(umapUrl, config) {
    importScripts(umapUrl);
    umap = new self.UMAP(config);
  };

  var fit = function fit(data, labels) {
    if (labels) umap.setSupervisedProjection(labels);
    return umap.fit(data);
  };

  var transform = function transform(data) {
    return umap.transform(data);
  };

  self.onmessage = function onmessage(e) {
    switch (e.data.task) {
      case 'create':
        create(e.data.umapUrl, e.data.config);
        break;

      case 'fit':
        self.postMessage(fit(e.data.data, e.data.labels));
        break;

      case 'transform':
        self.postMessage(transform(e.data.data));
        break;

      default:
        self.postMessage(error('Unknown or no task specified'));
        break;
    }
  };
};

function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

var arrayWithHoles = _arrayWithHoles;

function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

var iterableToArrayLimit = _iterableToArrayLimit;

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

var arrayLikeToArray = _arrayLikeToArray;

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
}

var unsupportedIterableToArray = _unsupportedIterableToArray;

function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

var nonIterableRest = _nonIterableRest;

function _slicedToArray(arr, i) {
  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
}

var slicedToArray = _slicedToArray;

var createScale = function createScale() {
  var transformer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function (x) {
    return x;
  };
  var domainMin = 1;
  var domainMinTransformed = Math.log10(domainMin);
  var domainMax = 10;
  var domainMaxTransformed = Math.log10(domainMax);
  var domainSize = domainMaxTransformed - domainMinTransformed;
  var rangeMin = 0;
  var rangeMax = 1;
  var rangeSize = 1;

  var scale = function scale(value) {
    return Math.min(rangeMax, Math.max(rangeMin, rangeMax - (domainMaxTransformed - transformer(value)) / domainSize * rangeSize));
  };

  scale.domain = function () {
    var newDomain = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    if (newDomain.length === 0) return [domainMin, domainMax];

    var _newDomain = slicedToArray(newDomain, 2),
        newDomainMin = _newDomain[0],
        newDomainMax = _newDomain[1];

    domainMin = newDomainMin;
    domainMinTransformed = transformer(newDomainMin);
    domainMax = newDomainMax;
    domainMaxTransformed = transformer(newDomainMax);
    domainSize = domainMaxTransformed - domainMinTransformed || 1;
    return scale;
  };

  scale.range = function () {
    var newRange = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    if (newRange.length === 0) return [rangeMin, rangeMax];

    var _newRange = slicedToArray(newRange, 2),
        newRangeMin = _newRange[0],
        newRangeMax = _newRange[1];

    rangeMin = newRangeMin;
    rangeMax = newRangeMax;
    rangeSize = rangeMax - rangeMin;
    return scale;
  };

  return scale;
};

var createUrlScript = function createUrlScript(fnStr) {
  return window.URL.createObjectURL(new Blob([fnStr], {
    type: 'text/javascript'
  }));
};

var createUmap = function createUmap(config) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$padding = _ref.padding,
      padding = _ref$padding === void 0 ? 0.1 : _ref$padding;

  var xScale = createScale();
  var yScale = createScale();
  var umapUrl = createUrlScript(umapScriptStr.replace('window', 'self'));
  var umapWorker = createWorker(worker);
  umapWorker.postMessage({
    task: 'create',
    config: config,
    umapUrl: umapUrl
  });
  var minX = Infinity;
  var minY = Infinity;
  var maxX = -Infinity;
  var maxY = -Infinity;

  var defineScales = function defineScales(embedding) {
    embedding.forEach(function (point) {
      minX = point[0] < minX ? point[0] : minX;
      minY = point[1] < minY ? point[1] : minY;
      maxX = point[0] > maxX ? point[0] : maxX;
      maxY = point[1] > maxY ? point[1] : maxY;
    }); // Some padding can be beneficial as piles keep moving around a little bit
    // every time they are transformed

    var xPad = (maxX - minX) * padding;
    var yPad = (maxY - minY) * padding;
    xScale.domain([minX - xPad, maxX + xPad]);
    yScale.domain([minY - yPad, maxY + yPad]);
    return embedding;
  };

  var scalePoint = function scalePoint(pt) {
    return [xScale(pt[0]), yScale(pt[1])];
  };

  var destroy = function destroy() {
    umapWorker.terminate();
  };

  var fit = function fit(data) {
    var labels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    minX = Infinity;
    minY = Infinity;
    maxX = -Infinity;
    maxY = -Infinity;
    return new Promise(function (resolve) {
      umapWorker.onmessage = function (event) {
        resolve(defineScales(event.data));
      };

      umapWorker.postMessage({
        task: 'fit',
        data: data,
        labels: labels
      });
    });
  };

  var transform = function transform(data) {
    if (!umapWorker) return Promise.reject(new Error('You need to fit data first!'));
    return new Promise(function (resolve) {
      umapWorker.onmessage = function (event) {
        resolve(event.data.map(scalePoint));
      };

      umapWorker.postMessage({
        task: 'transform',
        data: data
      });
    });
  };

  return {
    destroy: destroy,
    fit: fit,
    transform: transform
  };
};

export { createUmap };
